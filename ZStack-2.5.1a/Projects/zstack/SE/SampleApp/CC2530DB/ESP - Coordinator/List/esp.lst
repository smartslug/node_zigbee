###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         05/Aug/2016  10:43:58 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\Source\ESP\esp.c          #
#    Command line       =  -f G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\P #
#                          rojects\zstack\SE\SampleApp\CC2530DB\..\..\..\Tool #
#                          s\CC2530DB\f8wCoord.cfg (-DCPU32MHZ                #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\P #
#                          rojects\zstack\SE\SampleApp\CC2530DB\..\..\..\Tool #
#                          s\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0   #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x02000000                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x1688                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f                         #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\Tools\C #
#                          C2530DB\f8wZCL.cfg (-DZCL_READ -DZCL_WRITE         #
#                          -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF            #
#                          -DZCL_KEY_ESTABLISH -DZCL_KEY_ESTABLISHMENT_KEY_GE #
#                          NERATE_TIMEOUT=4 -DZCL_KEY_ESTABLISHMENT_MAC_GENER #
#                          ATE_TIMEOUT=10 -DZCL_KEY_ESTABLISHMENT_EKEY_GENERA #
#                          TE_TIMEOUT=10 -DZCL_LOAD_CONTROL                   #
#                          -DZCL_SIMPLE_METERING -DZCL_PRICING -DZCL_MESSAGE  #
#                          -DZCL_TUNNELING -DZCL_TOU) -DZCL_DEVICE_MGMT       #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\Source\ESP\esp.c -D       #
#                          TC_LINKKEY_JOIN -D ZTOOL_P1 -D MT_TASK -D          #
#                          MT_APP_FUNC -D MT_SYS_FUNC -D LCD_SUPPORTED -D     #
#                          INT_HEAP_LEN=2450 -D NV_INIT -D xNV_RESTORE -D     #
#                          ZCL_REPORT -D INTER_PAN -D                         #
#                          ZDSECMGR_TC_DEVICE_MAX=16 -D TEST_CERT_DATA -lC    #
#                          "G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Pro #
#                          jects\zstack\SE\SampleApp\CC2530DB\ESP -           #
#                          Coordinator\List\" -lA "G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®Î #
#                          ÞÏßQQ\ZStack-2.5.1a\Projects\zstack\SE\SampleApp\C #
#                          C2530DB\ESP - Coordinator\List\" --diag_suppress   #
#                          Pe001,Pa010 -o "G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZS #
#                          tack-2.5.1a\Projects\zstack\SE\SampleApp\CC2530DB\ #
#                          ESP - Coordinator\Obj\" -e --no_code_motion        #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\P #
#                          rojects\zstack\SE\SampleApp\CC2530DB\ -I           #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\Source\ -I    #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\Source\    #
#                          -I G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\P #
#                          rojects\zstack\SE\SampleApp\CC2530DB\..\..\..\ZMai #
#                          n\TI2530DB\ -I G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZSt #
#                          ack-2.5.1a\Projects\zstack\SE\SampleApp\CC2530DB\. #
#                          .\..\..\..\..\Components\hal\include\ -I           #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\hal\target\CC2530EB\ -I                  #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\mac\include\ -I                          #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\mac\high_level\ -I                       #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\mac\low_level\srf04\ -I                  #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\mac\low_level\srf04\single_chip\ -I      #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\mt\ -I G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\Z #
#                          Stack-2.5.1a\Projects\zstack\SE\SampleApp\CC2530DB #
#                          \..\..\..\..\..\Components\osal\include\ -I        #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\services\saddr\ -I                       #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\services\sdata\ -I                       #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\stack\af\ -I G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞ #
#                          ÏßQQ\ZStack-2.5.1a\Projects\zstack\SE\SampleApp\CC #
#                          2530DB\..\..\..\..\..\Components\stack\nwk\ -I     #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\stack\sapi\ -I                           #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\stack\sec\ -I G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®Î #
#                          ÞÏßQQ\ZStack-2.5.1a\Projects\zstack\SE\SampleApp\C #
#                          C2530DB\..\..\..\..\..\Components\stack\sys\ -I    #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\stack\zcl\ -I G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®Î #
#                          ÞÏßQQ\ZStack-2.5.1a\Projects\zstack\SE\SampleApp\C #
#                          C2530DB\..\..\..\..\..\Components\stack\zdo\ -I    #
#                          G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\zmac\ -I G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ #
#                          \ZStack-2.5.1a\Projects\zstack\SE\SampleApp\CC2530 #
#                          DB\..\..\..\..\..\Components\zmac\f8w\ -Ohz        #
#                          --require_prototypes                               #
#    List file          =  G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\ESP -            #
#                          Coordinator\List\esp.lst                           #
#    Object file        =  G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Proj #
#                          ects\zstack\SE\SampleApp\CC2530DB\ESP -            #
#                          Coordinator\Obj\esp.r51                            #
#                                                                             #
#                                                                             #
###############################################################################

G:\»ªÖÚÎÞÏß\12.´®¿ÚÍ¸´«Ö®ÎÞÏßQQ\ZStack-2.5.1a\Projects\zstack\SE\SampleApp\Source\ESP\esp.c
      1          /**************************************************************************************************
      2            Filename:       esp.c
      3            Revised:        $Date: 2012-04-02 17:02:19 -0700 (Mon, 02 Apr 2012) $
      4            Revision:       $Revision: 29996 $
      5          
      6            Description:    This module implements the ESP functionality and contains the
      7                            init and event loop functions
      8          
      9          
     10            Copyright 2009-2012 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42            This application is designed for the test purpose of the SE profile which
     43            exploits the following clusters for an ESP configuration:
     44          
     45            General Basic
     46            General Alarms
     47            General Time
     48            General Key Establishment
     49            SE     Price
     50            SE     Demand Response and Load Control
     51            SE     Simple Metering
     52            SE     Message
     53          
     54            Key control:
     55              SW1:  Send out Cooling Load Control Event to PCT
     56              SW2:  Send out Load Control Event to Load Control Device
     57              SW3:  Send out Message to In Premise Display
     58              SW4:  Not used
     59          *********************************************************************/
     60          
     61          /*********************************************************************
     62           * INCLUDES
     63           */
     64          
     65          #include "OSAL.h"
     66          #include "OSAL_Clock.h"
     67          #include "OSAL_Nv.h"
     68          #include "MT.h"
     69          #include "MT_APP.h"
     70          #include "ZDObject.h"
     71          #include "AddrMgr.h"
     72          
     73          #include "se.h"
     74          #include "esp.h"
     75          #include "zcl_general.h"
     76          #include "zcl_se.h"
     77          #include "zcl_key_establish.h"
     78          
     79          #if defined( INTER_PAN )
     80            #include "stub_aps.h"
     81          #endif
     82          
     83          #include "onboard.h"
     84          
     85          /* HAL */
     86          #include "hal_lcd.h"
     87          #include "hal_led.h"
     88          #include "hal_key.h"
     89          
     90          
     91          /*********************************************************************
     92           * MACROS
     93           */
     94          
     95          // There is no attribute in the Mandatory Reportable Attribute list for now
     96          #define zcl_MandatoryReportableAttribute( a ) ( a == NULL )
     97          
     98          /*********************************************************************
     99           * CONSTANTS
    100           */
    101          
    102          #define ESP_MIN_REPORTING_INTERVAL       5
    103          
    104          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
    105          // There can be up to ESP_MAX_MIRRORS mirror endpoints starting at the ESP_MIRROR_EP_BASE and
    106          // going up to ( ESP_MIRROR_EP_BASE + ESP_MAX_MIRRORS )
    107          #define ESP_MIRROR_EP_BASE                        24
    108          
    109          // The max number of mirrors the ESP can have.
    110          // Note: This value is limited by the number of bits in the mirrorMask mask
    111          #define ESP_MAX_MIRRORS                           16
    112          #define ESP_MIRROR_FULL_MASK                      0xFFFF
    113          
    114          #define ESP_MIRROR_NOTIFY_ATTR_COUNT              6
    115          #define ESP_MIRROR_USER_ATTRIBUTES_POSITION       ESP_MIRROR_NOTIFY_ATTR_COUNT
    116          #define ESP_MIRROR_MAX_USER_ATTRIBUTES            8
    117          #define ESP_MIRROR_MAX_ATTRIBUTES                 (ESP_MIRROR_NOTIFY_ATTR_COUNT + ESP_MIRROR_MAX_USER_ATTRIBUTES)
    118          #define ESP_MIRROR_INVALID_ENDPOINT               0xFF
    119          #endif  // SE_UK_EXT && SE_MIRROR
    120          
    121          /*********************************************************************
    122           * TYPEDEFS
    123           */
    124          
    125          /*********************************************************************
    126           * GLOBAL VARIABLES
    127           */
    128          
    129          /*********************************************************************
    130           * GLOBAL FUNCTIONS
    131           */
    132          
    133          /*********************************************************************
    134           * LOCAL VARIABLES
    135           */
    136          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    137          static uint8 espTaskID;                              // esp osal task id
   \                     espTaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    138          static afAddrType_t ipdAddr;                         // destination address of in premise display
   \                     ipdAddr:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    139          static afAddrType_t pctAddr;                         // destination address of PCT
   \                     pctAddr:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    140          static afAddrType_t loadControlAddr;                 // destination address of load control device
   \                     loadControlAddr:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    141          static zAddrType_t simpleDescReqAddr;                // destination addresses for simple desc request
   \                     simpleDescReqAddr:
   \   000000                DS 9
   \   000009                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    142          static zclCCLoadControlEvent_t loadControlCmd;       // command structure for load control command
   \                     loadControlCmd:
   \   000000                DS 24
   \   000018                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    143          static uint16 espFastPollModeDuration;               // number of fast poll events
   \                     espFastPollModeDuration:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    144          
    145          #if defined ( INTER_PAN )
    146          // define endpoint structure to register with STUB APS for INTER-PAN support

   \                                 In  segment XDATA_I, align 1, keep-with-next
    147          static endPointDesc_t espEp =
   \                     espEp:
   \   000000                DS 6
   \   000006                REQUIRE `?<Initializer for espEp>`
   \   000006                REQUIRE __INIT_XDATA_I
    148          {
    149            ESP_ENDPOINT,
    150            &espTaskID,
    151            (SimpleDescriptionFormat_t *)&espSimpleDesc,
    152            (afNetworkLatencyReq_t)0
    153          };
    154          #endif
    155          
    156          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
    157          typedef struct
    158          {
    159            uint16 srcAddr;
    160            uint8 srcEndpoint;
    161            zclAttrRec_t *pAttr;
    162            uint8 notificationControl;
    163            zclCCReqMirrorReportAttrRsp_t notificationSet;
    164          } espMirrorInfo_t;
    165          
    166          typedef struct
    167          {
    168            uint16 mirrorMask;
    169            espMirrorInfo_t mirrorInfo[ESP_MAX_MIRRORS];
    170          } espMirrorControl_t;
    171          
    172          #define MIRROR_DEVICE_VERSION       0
    173          #define MIRROR_FLAGS                0
    174          
    175          #define MIRROR_MAX_INCLUSTERS       2
    176          CONST cId_t mirrorInClusterList[MIRROR_MAX_INCLUSTERS] =
    177          {
    178            ZCL_CLUSTER_ID_GEN_BASIC,
    179            ZCL_CLUSTER_ID_SE_SIMPLE_METERING
    180          };
    181          
    182          #define MIRROR_MAX_OUTCLUSTERS       2
    183          CONST cId_t mirrorOutClusterList[MIRROR_MAX_OUTCLUSTERS] =
    184          {
    185            ZCL_CLUSTER_ID_GEN_BASIC,
    186            ZCL_CLUSTER_ID_SE_SIMPLE_METERING
    187          };
    188          #endif  // SE_UK_EXT && SE_MIRROR
    189          
    190          /*********************************************************************
    191           * LOCAL FUNCTIONS
    192           */
    193          static void esp_HandleKeys( uint8 shift, uint8 keys );
    194          static void esp_ProcessAppMsg( uint8 *msg );
    195          
    196          static void esp_ProcessIdentifyTimeChange( void );
    197          
    198          /*************************************************************************/
    199          /*** Application Callback Functions                                    ***/
    200          /*************************************************************************/
    201          
    202          // Foundation Callback functions
    203          static uint8 esp_ValidateAttrDataCB( zclAttrRec_t *pAttr, zclWriteRec_t *pAttrInfo );
    204          
    205          // General Cluster Callback functions
    206          static void esp_BasicResetCB( void );
    207          static void esp_IdentifyCB( zclIdentify_t *pCmd );
    208          static void esp_IdentifyQueryRspCB( zclIdentifyQueryRsp_t *pRsp );
    209          static void esp_AlarmCB( zclAlarm_t *pAlarm );
    210          #ifdef SE_UK_EXT
    211          static void esp_GetEventLogCB( uint8 srcEP, afAddrType_t *srcAddr,
    212                                         zclGetEventLog_t *pEventLog, uint8 seqNum );
    213          static void esp_PublishEventLogCB( afAddrType_t *srcAddr, zclPublishEventLog_t *pEventLog );
    214          #endif // SE_UK_EXT
    215          
    216          // SE Callback functions
    217          static void esp_GetProfileCmdCB( zclCCGetProfileCmd_t *pCmd,
    218                                                 afAddrType_t *srcAddr, uint8 seqNum );
    219          static void esp_GetProfileRspCB( zclCCGetProfileRsp_t *pCmd,
    220                                                 afAddrType_t *srcAddr, uint8 seqNum );
    221          static void esp_ReqMirrorCmdCB( afAddrType_t *srcAddr, uint8 seqNum );
    222          static void esp_ReqMirrorRspCB( zclCCReqMirrorRsp_t *pCmd,
    223                                                 afAddrType_t *srcAddr, uint8 seqNum );
    224          static void esp_MirrorRemCmdCB( afAddrType_t *srcAddr, uint8 seqNum );
    225          static void esp_MirrorRemRspCB( zclCCMirrorRemRsp_t *pCmd,
    226                                                 afAddrType_t *srcAddr, uint8 seqNum );
    227          static void esp_ReqFastPollModeCmdCB( zclCCReqFastPollModeCmd_t *pCmd,
    228                                                 afAddrType_t *srcAddr, uint8 seqNum );
    229          static void esp_ReqFastPollModeRspCB( zclCCReqFastPollModeRsp_t *pRsp,
    230                                                 afAddrType_t *srcAddr, uint8 seqNum );
    231          static void esp_GetCurrentPriceCB( zclCCGetCurrentPrice_t *pCmd,
    232                                                 afAddrType_t *srcAddr, uint8 seqNum );
    233          static void esp_GetScheduledPriceCB( zclCCGetScheduledPrice_t *pCmd,
    234                                                 afAddrType_t *srcAddr, uint8 seqNum );
    235          static void esp_PriceAcknowledgementCB( zclCCPriceAcknowledgement_t *pCmd,
    236                                                 afAddrType_t *srcAddr, uint8 seqNum );
    237          static void esp_GetBlockPeriodCB( zclCCGetBlockPeriod_t *pCmd,
    238                                                 afAddrType_t *srcAddr, uint8 seqNum );
    239          static void esp_PublishPriceCB( zclCCPublishPrice_t *pCmd,
    240                                                 afAddrType_t *srcAddr, uint8 seqNum );
    241          static void esp_PublishBlockPeriodCB( zclCCPublishBlockPeriod_t *pCmd,
    242                                                 afAddrType_t *srcAddr, uint8 seqNum );
    243          static void esp_DisplayMessageCB( zclCCDisplayMessage_t *pCmd,
    244                                                 afAddrType_t *srcAddr, uint8 seqNum );
    245          static void esp_CancelMessageCB( zclCCCancelMessage_t *pCmd,
    246                                                 afAddrType_t *srcAddr, uint8 seqNum );
    247          static void esp_GetLastMessageCB( afAddrType_t *srcAddr, uint8 seqNum );
    248          static void esp_MessageConfirmationCB( zclCCMessageConfirmation_t *pCmd,
    249                                                 afAddrType_t *srcAddr, uint8 seqNum );
    250          static void esp_LoadControlEventCB( zclCCLoadControlEvent_t *pCmd,
    251                                    afAddrType_t *srcAddr, uint8 status, uint8 seqNum);
    252          static void esp_CancelLoadControlEventCB( zclCCCancelLoadControlEvent_t *pCmd,
    253                                                 afAddrType_t *srcAddr, uint8 seqNum );
    254          static void esp_CancelAllLoadControlEventsCB( zclCCCancelAllLoadControlEvents_t *pCmd,
    255                                                 afAddrType_t *srcAddr, uint8 seqNum );
    256          static void esp_ReportEventStatusCB( zclCCReportEventStatus_t *pCmd,
    257                                                 afAddrType_t *srcAddr, uint8 seqNum );
    258          static void esp_GetScheduledEventCB( zclCCGetScheduledEvent_t *pCmd,
    259                                                 afAddrType_t *srcAddr, uint8 seqNum );
    260          static void esp_SelAvailEmergencyCreditCmdCB( zclCCSelAvailEmergencyCredit_t *pCmd,
    261                                                 afAddrType_t *srcAddr, uint8 seqNum );
    262          static void esp_ChangeSupplyCmdCB( zclCCChangeSupply_t *pCmd,
    263                                                 afAddrType_t *srcAddr, uint8 seqNum );
    264          static void esp_SupplyStatusRspCB( zclCCSupplyStatusResponse_t *pCmd,
    265                                                 afAddrType_t *srcAddr, uint8 seqNum );
    266          #if defined ( SE_UK_EXT )
    267          static void esp_GetSnapshotRspCB( zclCCReqGetSnapshotRsp_t *pCmd,
    268                                                 afAddrType_t *srcAddr, uint8 seqNum );
    269          static void esp_PublishTariffInformationCB( zclCCPublishTariffInformation_t *pCmd,
    270                                                 afAddrType_t *srcAddr, uint8 seqNum );
    271          static void esp_PublishPriceMatrixCB( zclCCPublishPriceMatrix_t *pCmd,
    272                                                 afAddrType_t *srcAddr, uint8 seqNum );
    273          static void esp_PublishBlockThresholdsCB( zclCCPublishBlockThresholds_t *pCmd,
    274                                                 afAddrType_t *srcAddr, uint8 seqNum );
    275          static void esp_PublishConversionFactorCB( zclCCPublishConversionFactor_t *pCmd,
    276                                                 afAddrType_t *srcAddr, uint8 seqNum );
    277          static void esp_PublishCalorificValueCB( zclCCPublishCalorificValue_t *pCmd,
    278                                                 afAddrType_t *srcAddr, uint8 seqNum );
    279          static void esp_PublishCO2ValueCB( zclCCPublishCO2Value_t *pCmd,
    280                                                 afAddrType_t *srcAddr, uint8 seqNum );
    281          static void esp_PublishCPPEventCB( zclCCPublishCPPEvent_t *pCmd,
    282                                                 afAddrType_t *srcAddr, uint8 seqNum );
    283          static void esp_PublishBillingPeriodCB( zclCCPublishBillingPeriod_t *pCmd,
    284                                                 afAddrType_t *srcAddr, uint8 seqNum );
    285          static void esp_PublishConsolidatedBillCB( zclCCPublishConsolidatedBill_t *pCmd,
    286                                                 afAddrType_t *srcAddr, uint8 seqNum );
    287          static void esp_PublishCreditPaymentInfoCB( zclCCPublishCreditPaymentInfo_t *pCmd,
    288                                                 afAddrType_t *srcAddr, uint8 seqNum );
    289          static void esp_GetTariffInformationCB( zclCCGetTariffInformation_t *pCmd,
    290                                                 afAddrType_t *srcAddr, uint8 seqNum );
    291          static void esp_GetPriceMatrixCB( uint32 issuerTariffId,
    292                                                 afAddrType_t *srcAddr, uint8 seqNum );
    293          static void esp_GetBlockThresholdsCB( uint32 issuerTariffId,
    294                                                 afAddrType_t *srcAddr, uint8 seqNum );
    295          static void esp_GetConversionFactorCB( zclCCGetConversionFactor_t *pCmd,
    296                                                 afAddrType_t *srcAddr, uint8 seqNum );
    297          static void esp_GetCalorificValueCB( zclCCGetCalorificValue_t *pCmd,
    298                                                 afAddrType_t *srcAddr, uint8 seqNum );
    299          static void esp_GetCO2ValueCB( zclCCGetCO2Value_t *pCmd,
    300                                                 afAddrType_t *srcAddr, uint8 seqNum );
    301          static void esp_GetBillingPeriodCB( zclCCGetBillingPeriod_t *pCmd,
    302                                                 afAddrType_t *srcAddr, uint8 seqNum );
    303          static void esp_GetConsolidatedBillCB( zclCCGetConsolidatedBill_t *pCmd,
    304                                                 afAddrType_t *srcAddr, uint8 seqNum );
    305          static void esp_CPPEventResponseCB( zclCCCPPEventResponse_t *pCmd,
    306                                                 afAddrType_t *srcAddr, uint8 seqNum );
    307          static void esp_ChangeDebtCB( zclCCChangeDebt_t *pCmd,
    308                                                 afAddrType_t *srcAddr, uint8 seqNum );
    309          static void esp_EmergencyCreditSetupCB( zclCCEmergencyCreditSetup_t *pCmd,
    310                                                 afAddrType_t *srcAddr, uint8 seqNum );
    311          static void esp_ConsumerTopupCB( zclCCConsumerTopup_t *pCmd,
    312                                                 afAddrType_t *srcAddr, uint8 seqNum );
    313          static void esp_CreditAdjustmentCB( zclCCCreditAdjustment_t *pCmd,
    314                                                 afAddrType_t *srcAddr, uint8 seqNum );
    315          static void esp_ChangePaymentModeCB( zclCCChangePaymentMode_t *pCmd,
    316                                                 afAddrType_t *srcAddr, uint8 seqNum );
    317          static void esp_GetPrepaySnapshotCB( zclCCGetPrepaySnapshot_t *pCmd,
    318                                                 afAddrType_t *srcAddr, uint8 seqNum );
    319          static void esp_GetTopupLogCB( uint8 numEvents,
    320                                                 afAddrType_t *srcAddr, uint8 seqNum );
    321          static void esp_SetLowCreditWarningLevelCB( uint8 numEvents,
    322                                                 afAddrType_t *srcAddr, uint8 seqNum );
    323          static void esp_GetDebtRepaymentLogCB( zclCCGetDebtRepaymentLog_t *pCmd,
    324                                                 afAddrType_t *srcAddr, uint8 seqNum );
    325          static void esp_GetPrepaySnapshotResponseCB( zclCCGetPrepaySnapshotResponse_t *pCmd,
    326                                                 afAddrType_t *srcAddr, uint8 seqNum );
    327          static void esp_ChangePaymentModeResponseCB( zclCCChangePaymentModeResponse_t *pCmd,
    328                                                 afAddrType_t *srcAddr, uint8 seqNum );
    329          static void esp_ConsumerTopupResponseCB( zclCCConsumerTopupResponse_t *pCmd,
    330                                                 afAddrType_t *srcAddr, uint8 seqNum );
    331          static void esp_GetCommandsCB( uint8 prepayNotificationFlags,
    332                                                 afAddrType_t *srcAddr, uint8 seqNum );
    333          static void esp_PublishTopupLogCB( zclCCPublishTopupLog_t *pCmd,
    334                                                 afAddrType_t *srcAddr, uint8 seqNum );
    335          static void esp_PublishDebtLogCB( zclCCPublishDebtLog_t *pCmd,
    336                                                 afAddrType_t *srcAddr, uint8 seqNum );
    337          #endif  // SE_UK_EXT
    338          
    339          /************************************************************************/
    340          /***               Functions to process ZCL Foundation                ***/
    341          /***               incoming Command/Response messages                 ***/
    342          /************************************************************************/
    343          static void esp_ProcessZCLMsg( zclIncomingMsg_t *msg );
    344          #if defined ( ZCL_READ )
    345          static uint8 esp_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg );
    346          #endif // ZCL_READ
    347          #if defined ( ZCL_WRITE )
    348          static uint8 esp_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg );
    349          #endif // ZCL_WRITE
    350          #if defined ( ZCL_REPORT )
    351          static uint8 esp_ProcessInConfigReportCmd( zclIncomingMsg_t *pInMsg );
    352          static uint8 esp_ProcessInConfigReportRspCmd( zclIncomingMsg_t *pInMsg );
    353          static uint8 esp_ProcessInReadReportCfgCmd( zclIncomingMsg_t *pInMsg );
    354          static uint8 esp_ProcessInReadReportCfgRspCmd( zclIncomingMsg_t *pInMsg );
    355          static uint8 esp_ProcessInReportCmd( zclIncomingMsg_t *pInMsg );
    356          #endif // ZCL_REPORT
    357          static uint8 esp_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg );
    358          #if defined ( ZCL_DISCOVER )
    359          static uint8 esp_ProcessInDiscRspCmd( zclIncomingMsg_t *pInMsg );
    360          #endif // ZCL_DISCOVER
    361          
    362          // Functions to handle ZDO messages
    363          static void esp_ProcessZDOMsg( zdoIncomingMsg_t *inMsg );
    364          
    365          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
    366          static void esp_MirrorInit( void );
    367          static uint8 esp_GetMirrorEndpoint( afAddrType_t *srcAddr );
    368          static uint8 esp_AllocMirror( afAddrType_t *srcAddr );
    369          static void esp_FreeMirror( uint8 endPoint );
    370          static uint8 esp_IsMirrorEndpoint( uint8 endpoint );
    371          static void esp_MirrorProcessZCLMsg( zclIncomingMsg_t *pInMsg );
    372          static espMirrorInfo_t *esp_GetMirrorInfo( uint8 endpoint );
    373          static uint8 esp_MirrorUpdateAttribute( uint8 endpoint, uint16 cluster,
    374                                                  zclReport_t *pReport );
    375          static void esp_MirrorInitAttributeSet( uint8 endpoint );
    376          
    377          static espMirrorControl_t esp_MirrorControl;
    378          #endif  // SE_UK_EXT && SE_MIRROR
    379          
    380          /*********************************************************************
    381           * ZCL General Clusters Callback table
    382           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    383          static zclGeneral_AppCallbacks_t esp_GenCmdCallbacks =
   \                     esp_GenCmdCallbacks:
   \   000000                DS 30
   \   00001E                REQUIRE `?<Initializer for esp_GenCmdCallbacks>`
   \   00001E                REQUIRE __INIT_XDATA_I
    384          {
    385            esp_BasicResetCB,              // Basic Cluster Reset command
    386            esp_IdentifyCB,                // Identify command
    387            esp_IdentifyQueryRspCB,        // Identify Query Response command
    388            NULL,                          // On/Off cluster commands
    389            NULL,                          // Level Control Move to Level command
    390            NULL,                          // Level Control Move command
    391            NULL,                          // Level Control Step command
    392            NULL,                          // Level Control Stop command
    393            NULL,                          // Group Response commands
    394            NULL,                          // Scene Store Request command
    395            NULL,                          // Scene Recall Request command
    396            NULL,                          // Scene Response command
    397            esp_AlarmCB,                   // Alarm (Response) command
    398          #ifdef SE_UK_EXT
    399            esp_GetEventLogCB,             // Get Event Log command
    400            esp_PublishEventLogCB,         // Publish Event Log command
    401          #endif
    402            NULL,                          // RSSI Location command
    403            NULL                           // RSSI Location Response command
    404          };
    405          
    406          /*********************************************************************
    407           * ZCL SE Clusters Callback table
    408           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    409          static zclSE_AppCallbacks_t esp_SECmdCallbacks =
   \                     esp_SECmdCallbacks:
   \   000000                DS 66
   \   000042                REQUIRE `?<Initializer for esp_SECmdCallbacks>`
   \   000042                REQUIRE __INIT_XDATA_I
    410          {
    411            esp_PublishPriceCB,                      // Publish Price
    412            esp_PublishBlockPeriodCB,                // Publish Block Period
    413          #if defined ( SE_UK_EXT )
    414            esp_PublishTariffInformationCB,          // Publish Tariff Information
    415            esp_PublishPriceMatrixCB,                // Publish Price Matrix
    416            esp_PublishBlockThresholdsCB,            // Publish Block Thresholds
    417            esp_PublishConversionFactorCB,           // Publish Conversion Factor
    418            esp_PublishCalorificValueCB,             // Publish Calorific Value
    419            esp_PublishCO2ValueCB,                   // Publish CO2 Value
    420            esp_PublishCPPEventCB,                   // Publish CPP Event
    421            esp_PublishBillingPeriodCB,              // Publish Billing Period
    422            esp_PublishConsolidatedBillCB,           // Publish Consolidated Bill
    423            esp_PublishCreditPaymentInfoCB,          // Publish Credit Payment Info
    424          #endif  // SE_UK_EXT
    425            esp_GetCurrentPriceCB,                   // Get Current Price
    426            esp_GetScheduledPriceCB,                 // Get Scheduled Price
    427            esp_PriceAcknowledgementCB,              // Price Acknowledgement
    428            esp_GetBlockPeriodCB,                    // Get Block Period
    429          #if defined ( SE_UK_EXT )
    430            esp_GetTariffInformationCB,              // Get Tariff Information
    431            esp_GetPriceMatrixCB,                    // Get Price Matrix
    432            esp_GetBlockThresholdsCB,                // Get Block Thresholds
    433            esp_GetConversionFactorCB,               // Get Conversion Factor
    434            esp_GetCalorificValueCB,                 // Get Calorific Value
    435            esp_GetCO2ValueCB,                       // Get CO2 Value
    436            esp_GetBillingPeriodCB,                  // Get Billing Period
    437            esp_GetConsolidatedBillCB,               // Get Consolidated Bill
    438            esp_CPPEventResponseCB,                  // CPP Event Response
    439          #endif  // SE_UK_EXT
    440            esp_LoadControlEventCB,                  // Load Control Event
    441            esp_CancelLoadControlEventCB,            // Cancel Load Control Event
    442            esp_CancelAllLoadControlEventsCB,        // Cancel All Load Control Events
    443            esp_ReportEventStatusCB,                 // Report Event Status
    444            esp_GetScheduledEventCB,                 // Get Scheduled Event
    445            esp_GetProfileRspCB,                     // Get Profile Response
    446            esp_ReqMirrorCmdCB,                      // Request Mirror Command
    447            esp_MirrorRemCmdCB,                      // Mirror Remove Command
    448            esp_ReqFastPollModeRspCB,                // Request Fast Poll Mode Response
    449          #if defined ( SE_UK_EXT )
    450            esp_GetSnapshotRspCB,                    // Get Snapshot Response
    451          #endif  // SE_UK_EXT
    452            esp_GetProfileCmdCB,                     // Get Profile Command
    453            esp_ReqMirrorRspCB,                      // Request Mirror Response
    454            esp_MirrorRemRspCB,                      // Mirror Remove Response
    455            esp_ReqFastPollModeCmdCB,                // Request Fast Poll Mode Command
    456          #if defined ( SE_UK_EXT )
    457            NULL,                                    // Get Snapshot Command
    458            NULL,                                    // Take Snapshot Command
    459            NULL,                                    // Mirror Report Attribute Response
    460          #endif  // SE_UK_EXT
    461            esp_DisplayMessageCB,                    // Display Message Command
    462            esp_CancelMessageCB,                     // Cancel Message Command
    463            esp_GetLastMessageCB,                    // Get Last Message Command
    464            esp_MessageConfirmationCB,               // Message Confirmation
    465            NULL,                                    // Request Tunnel Response
    466            NULL,                                    // Transfer Data
    467            NULL,                                    // Transfer Data Error
    468            NULL,                                    // Ack Transfer Data
    469            NULL,                                    // Ready Data
    470          #if defined ( SE_UK_EXT )
    471            NULL,                                    // Supported Tunnel Protocols Response
    472            NULL,                                    // Tunnel Closure Notification
    473          #endif  // SE_UK_EXT
    474            NULL,                                    // Request Tunnel
    475            NULL,                                    // Close Tunnel
    476          #if defined ( SE_UK_EXT )
    477            NULL,                                    // Get Supported Tunnel Protocols
    478          #endif  // SE_UK_EXT
    479            esp_SupplyStatusRspCB,                   // Supply Status Response
    480          #if defined ( SE_UK_EXT )
    481            esp_GetPrepaySnapshotResponseCB,         // Get Prepay Snapshot Response
    482            esp_ChangePaymentModeResponseCB,         // Change Payment Mode Response
    483            esp_ConsumerTopupResponseCB,             // Consumer Topup Response
    484            esp_GetCommandsCB,                       // Get Commands
    485            esp_PublishTopupLogCB,                   // Publish Topup Log
    486            esp_PublishDebtLogCB,                    // Publish Debt Log
    487          #endif  // SE_UK_EXT
    488            esp_SelAvailEmergencyCreditCmdCB,        // Select Available Emergency Credit Command
    489            esp_ChangeSupplyCmdCB,                   // Change Supply Command
    490          #if defined ( SE_UK_EXT )
    491            esp_ChangeDebtCB,                        // Change Debt
    492            esp_EmergencyCreditSetupCB,              // Emergency Credit Setup
    493            esp_ConsumerTopupCB,                     // Consumer Topup
    494            esp_CreditAdjustmentCB,                  // Credit Adjustment
    495            esp_ChangePaymentModeCB,                 // Change PaymentMode
    496            esp_GetPrepaySnapshotCB,                 // Get Prepay Snapshot
    497            esp_GetTopupLogCB,                       // Get Topup Log
    498            esp_SetLowCreditWarningLevelCB,          // Set Low Credit Warning Level
    499            esp_GetDebtRepaymentLogCB,               // Get Debt Repayment Log
    500            NULL,                                    // Publish Calendar
    501            NULL,                                    // Publish Day Profile
    502            NULL,                                    // Publish Week Profile
    503            NULL,                                    // Publish Seasons
    504            NULL,                                    // Publish Special Days
    505            NULL,                                    // Get Calendar
    506            NULL,                                    // Get Day Profiles
    507            NULL,                                    // Get Week Profiles
    508            NULL,                                    // Get Seasons
    509            NULL,                                    // Get Special Days
    510            NULL,                                    // Publish Change Tenancy
    511            NULL,                                    // Publish Change Supplier
    512            NULL,                                    // Change Supply
    513            NULL,                                    // Change Password
    514            NULL,                                    // Local Change Supply
    515            NULL,                                    // Get Change Tenancy
    516            NULL,                                    // Get Change Supplier
    517            NULL,                                    // Get Change Supply
    518            NULL,                                    // Supply Status Response
    519            NULL,                                    // Get Password
    520          #endif  // SE_UK_EXT
    521          };
    522          
    523          /*********************************************************************
    524           * @fn          esp_Init
    525           *
    526           * @brief       Initialization function for the ZCL App Application.
    527           *
    528           * @param       uint8 task_id - esp task id
    529           *
    530           * @return      none
    531           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    532          void esp_Init( uint8 task_id )
   \                     esp_Init:
    533          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
    534            espTaskID = task_id;
   \   00000B   90....       MOV     DPTR,#espTaskID
   \   00000E   F0           MOVX    @DPTR,A
    535          
    536            // Register for an SE endpoint
    537            zclSE_Init( &espSimpleDesc );
   \   00000F                ; Setup parameters for call to function zclSE_Init
   \   00000F   7A..         MOV     R2,#espSimpleDesc & 0xff
   \   000011   7B..         MOV     R3,#(espSimpleDesc >> 8) & 0xff
   \   000013   12....       LCALL   ??zclSE_Init?relay
    538          
    539            // Register the ZCL General Cluster Library callback functions
    540            zclGeneral_RegisterCmdCallbacks( ESP_ENDPOINT, &esp_GenCmdCallbacks );
   \   000016                ; Setup parameters for call to function zclGeneral_RegisterCmdCallbacks
   \   000016   7A..         MOV     R2,#esp_GenCmdCallbacks & 0xff
   \   000018   7B..         MOV     R3,#(esp_GenCmdCallbacks >> 8) & 0xff
   \   00001A   7909         MOV     R1,#0x9
   \   00001C   12....       LCALL   ??zclGeneral_RegisterCmdCallbacks?relay
    541          
    542            // Register the ZCL SE Cluster Library callback functions
    543            zclSE_RegisterCmdCallbacks( ESP_ENDPOINT, &esp_SECmdCallbacks );
   \   00001F                ; Setup parameters for call to function zclSE_RegisterCmdCallbacks
   \   00001F   7A..         MOV     R2,#esp_SECmdCallbacks & 0xff
   \   000021   7B..         MOV     R3,#(esp_SECmdCallbacks >> 8) & 0xff
   \   000023   7909         MOV     R1,#0x9
   \   000025   12....       LCALL   ??zclSE_RegisterCmdCallbacks?relay
    544          
    545            // Register the application's attribute list
    546            zcl_registerAttrList( ESP_ENDPOINT, ESP_MAX_ATTRIBUTES, espAttrs );
   \   000028                ; Setup parameters for call to function zcl_registerAttrList
   \   000028   7C..         MOV     R4,#espAttrs & 0xff
   \   00002A   7D..         MOV     R5,#(espAttrs >> 8) & 0xff
   \   00002C   7A59         MOV     R2,#0x59
   \   00002E   7909         MOV     R1,#0x9
   \   000030   12....       LCALL   ??zcl_registerAttrList?relay
    547          
    548            // Register the application's cluster option list
    549            zcl_registerClusterOptionList( ESP_ENDPOINT, ESP_MAX_OPTIONS, espOptions );
   \   000033                ; Setup parameters for call to function zcl_registerClusterOptionList
   \   000033   7C..         MOV     R4,#espOptions & 0xff
   \   000035   7D..         MOV     R5,#(espOptions >> 8) & 0xff
   \   000037   7A07         MOV     R2,#0x7
   \   000039   7909         MOV     R1,#0x9
   \   00003B   12....       LCALL   ??zcl_registerClusterOptionList?relay
    550          
    551            // Register the application's attribute data validation callback function
    552            zcl_registerValidateAttrData( esp_ValidateAttrDataCB );
   \   00003E                ; Setup parameters for call to function zcl_registerValidateAttrData
   \   00003E   7A..         MOV     R2,#??esp_ValidateAttrDataCB?relay & 0xff
   \   000040   7B..         MOV     R3,#(??esp_ValidateAttrDataCB?relay >> 8) & 0xff
   \   000042   12....       LCALL   ??zcl_registerValidateAttrData?relay
    553          
    554            // Register the Application to receive the unprocessed Foundation command/response messages
    555            zcl_registerForMsg( espTaskID );
   \   000045                ; Setup parameters for call to function zcl_registerForMsg
   \   000045   90....       MOV     DPTR,#espTaskID
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F9           MOV     R1,A
   \   00004A   12....       LCALL   ??zcl_registerForMsg?relay
    556          
    557            // register for end device annce and simple descriptor responses
    558            ZDO_RegisterForZDOMsg( espTaskID, Device_annce );
   \   00004D                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   00004D   7A13         MOV     R2,#0x13
   \   00004F   7B00         MOV     R3,#0x0
   \   000051   90....       MOV     DPTR,#espTaskID
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F9           MOV     R1,A
   \   000056   12....       LCALL   ??ZDO_RegisterForZDOMsg?relay
    559            ZDO_RegisterForZDOMsg( espTaskID, Simple_Desc_rsp );
   \   000059                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000059   7A04         MOV     R2,#0x4
   \   00005B   7B80         MOV     R3,#-0x80
   \   00005D   90....       MOV     DPTR,#espTaskID
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F9           MOV     R1,A
   \   000062   12....       LCALL   ??ZDO_RegisterForZDOMsg?relay
    560          
    561            // Register for all key events - This app will handle all key events
    562            RegisterForKeys( espTaskID );
   \   000065                ; Setup parameters for call to function RegisterForKeys
   \   000065   90....       MOV     DPTR,#espTaskID
   \   000068   E0           MOVX    A,@DPTR
   \   000069   F9           MOV     R1,A
   \   00006A   12....       LCALL   ??RegisterForKeys?relay
    563          
    564          #if defined ( INTER_PAN )
    565            // Register with Stub APS
    566            StubAPS_RegisterApp( &espEp );
   \   00006D                ; Setup parameters for call to function StubAPS_RegisterApp
   \   00006D   7A..         MOV     R2,#espEp & 0xff
   \   00006F   7B..         MOV     R3,#(espEp >> 8) & 0xff
   \   000071   12....       LCALL   ??StubAPS_RegisterApp?relay
    567          #endif
    568          
    569            // Start the timer to sync esp timer with the osal timer
    570            osal_start_timerEx( espTaskID, ESP_UPDATE_TIME_EVT, ESP_UPDATE_TIME_PERIOD );
   \   000074                ; Setup parameters for call to function osal_start_timerEx
   \   000074   12....       LCALL   ?Subroutine16 & 0xFFFF
    571          
    572            // setup address mode and destination endpoint fields for PCT
    573            pctAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \                     ??CrossCallReturnLabel_39:
   \   000077   90....       MOV     DPTR,#pctAddr + 8
   \   00007A   7402         MOV     A,#0x2
   \   00007C   F0           MOVX    @DPTR,A
    574            pctAddr.endPoint = ESP_ENDPOINT;
   \   00007D   A3           INC     DPTR
   \   00007E   7409         MOV     A,#0x9
   \   000080   F0           MOVX    @DPTR,A
    575          
    576            // setup address mode and destination endpoint fields for load control device
    577            loadControlAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   000081   90....       MOV     DPTR,#loadControlAddr + 8
   \   000084   7402         MOV     A,#0x2
   \   000086   F0           MOVX    @DPTR,A
    578            loadControlAddr.endPoint = ESP_ENDPOINT;
   \   000087   A3           INC     DPTR
   \   000088   7409         MOV     A,#0x9
   \   00008A   F0           MOVX    @DPTR,A
    579          
    580            //setup load control command structure
    581            loadControlCmd.issuerEvent = 0x12345678;            // arbitrary id
   \   00008B   90....       MOV     DPTR,#__Constant_12345678
   \   00008E   12....       LCALL   ?XLOAD_R2345
   \   000091   90....       MOV     DPTR,#loadControlCmd
   \   000094   12....       LCALL   ?XSTORE_R2345
    582            loadControlCmd.deviceGroupClass = 0x000000;         // addresses all groups
   \   000097   90....       MOV     DPTR,#__Constant_0
   \   00009A   12....       LCALL   ?XLOAD_R2345
   \   00009D   90....       MOV     DPTR,#loadControlCmd + 4
   \   0000A0   12....       LCALL   ?XSTORE_R2345
    583            loadControlCmd.startTime = 0x00000000;              // start time = NOW
   \   0000A3   90....       MOV     DPTR,#__Constant_0
   \   0000A6   12....       LCALL   ?XLOAD_R2345
   \   0000A9   90....       MOV     DPTR,#loadControlCmd + 8
   \   0000AC   12....       LCALL   ?XSTORE_R2345
    584            loadControlCmd.durationInMinutes = 0x0001;          // duration of one minute
   \   0000AF   90....       MOV     DPTR,#loadControlCmd + 12
   \   0000B2   7401         MOV     A,#0x1
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   E4           CLR     A
   \   0000B7   F0           MOVX    @DPTR,A
    585            loadControlCmd.criticalityLevel = 0x01;             // green level
   \   0000B8   A3           INC     DPTR
   \   0000B9   04           INC     A
   \   0000BA   F0           MOVX    @DPTR,A
    586            loadControlCmd.coolingTemperatureSetPoint = 0x076C; // 19 degrees C, 66.2 degress fahrenheit
   \   0000BB   90....       MOV     DPTR,#loadControlCmd + 17
   \   0000BE   746C         MOV     A,#0x6c
   \   0000C0   F0           MOVX    @DPTR,A
   \   0000C1   A3           INC     DPTR
   \   0000C2   7407         MOV     A,#0x7
   \   0000C4   F0           MOVX    @DPTR,A
    587            loadControlCmd.eventControl = 0x00;                 // no randomized start or end applied
   \   0000C5   90....       MOV     DPTR,#loadControlCmd + 23
   \   0000C8   E4           CLR     A
   \   0000C9   F0           MOVX    @DPTR,A
    588          
    589            // Initialize variable used to control number of fast poll events
    590            espFastPollModeDuration = 0;
   \   0000CA   90....       MOV     DPTR,#espFastPollModeDuration
   \   0000CD   F0           MOVX    @DPTR,A
   \   0000CE   A3           INC     DPTR
   \   0000CF   F0           MOVX    @DPTR,A
    591          
    592            // detect and remove stored deprecated end device children after power up
    593            uint8 cleanupChildTable = TRUE;
   \   0000D0   85..82       MOV     DPL,?XSP + 0
   \   0000D3   85..83       MOV     DPH,?XSP + 1
   \   0000D6   04           INC     A
   \   0000D7   F0           MOVX    @DPTR,A
    594            zgSetItem( ZCD_NV_ROUTER_OFF_ASSOC_CLEANUP, sizeof(cleanupChildTable), &cleanupChildTable );
   \   0000D8                ; Setup parameters for call to function zgSetItem
   \   0000D8   8582..       MOV     ?V0 + 0,DPL
   \   0000DB   8583..       MOV     ?V0 + 1,DPH
   \   0000DE   78..         MOV     R0,#?V0 + 0
   \   0000E0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E3   7C01         MOV     R4,#0x1
   \   0000E5   7D00         MOV     R5,#0x0
   \   0000E7   7A3C         MOV     R2,#0x3c
   \   0000E9   7B00         MOV     R3,#0x0
   \   0000EB   12....       LCALL   ??zgSetItem?relay
   \   0000EE   7402         MOV     A,#0x2
   \   0000F0   12....       LCALL   ?DEALLOC_XSTACK8
    595          
    596          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
    597            esp_MirrorInit();
    598          #endif  // SE_UK_EXT && SE_MIRROR
    599          
    600          }
   \   0000F3   7401         MOV     A,#0x1
   \   0000F5   80..         SJMP    ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   7CE8         MOV     R4,#-0x18
   \   000002   7D03         MOV     R5,#0x3
   \   000004   7A02         MOV     R2,#0x2
   \   000006                REQUIRE ??Subroutine26_0
   \   000006                ; // Fall through to label ??Subroutine26_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine26_0:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   90....       MOV     DPTR,#espTaskID
   \   000005   E0           MOVX    A,@DPTR
   \   000006   F9           MOV     R1,A
   \   000007   12....       LCALL   ??osal_start_timerEx?relay
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine27_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F02         MOV     R7,#0x2
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
    601          
    602          /*********************************************************************
    603           * @fn          esp_event_loop
    604           *
    605           * @brief       Event Loop Processor for esp.
    606           *
    607           * @param       uint8 task_id - esp task id
    608           * @param       uint16 events - event bitmask
    609           *
    610           * @return      none
    611           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    612          uint16 esp_event_loop( uint8 task_id, uint16 events )
   \                     esp_event_loop:
    613          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    614            afIncomingMSGPacket_t *MSGpkt;
    615          
    616            if ( events & SYS_EVENT_MSG )
   \   000009   5480         ANL     A,#0x80
   \   00000B   702A         JNZ     ??esp_event_loop_0
    617            {
    618              while ( (MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( espTaskID )) )
    619              {
    620                switch ( MSGpkt->hdr.event )
    621                {
    622                  case MT_SYS_APP_MSG:
    623                    // Message received from MT (serial port)
    624                    esp_ProcessAppMsg( ((mtSysAppMsg_t *)MSGpkt)->appData );
    625                    break;
    626          
    627                  case ZCL_INCOMING_MSG:
    628                    // Incoming ZCL foundation command/response messages
    629                    esp_ProcessZCLMsg( (zclIncomingMsg_t *)MSGpkt );
    630                    break;
    631          
    632                  case KEY_CHANGE:
    633                    esp_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
    634                    break;
    635          
    636                  case ZDO_CB_MSG:
    637                    // ZDO sends the message that we registered for
    638                    esp_ProcessZDOMsg( (zdoIncomingMsg_t *)MSGpkt );
    639                    break;
    640          
    641                  default:
    642                    break;
    643                }
    644          
    645                // Release the memory
    646                osal_msg_deallocate( (uint8 *)MSGpkt );
    647          
    648              }
    649          
    650              // return unprocessed events
    651              return (events ^ SYS_EVENT_MSG);
    652            }
    653          
    654            // handle processing of identify timeout event triggered by an identify command
    655            if ( events & ESP_IDENTIFY_TIMEOUT_EVT )
   \   00000D   EE           MOV     A,R6
   \   00000E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000010   5068         JNC     ??esp_event_loop_1
    656            {
    657              if ( espIdentifyTime > 0 )
   \   000012   90....       MOV     DPTR,#espIdentifyTime
   \   000015   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000018   6007         JZ      ??esp_event_loop_2
    658              {
    659                espIdentifyTime--;
   \   00001A   90....       MOV     DPTR,#espIdentifyTime
   \   00001D   12....       LCALL   ?Subroutine17 & 0xFFFF
    660              }
   \                     ??CrossCallReturnLabel_27:
   \   000020   F0           MOVX    @DPTR,A
    661              esp_ProcessIdentifyTimeChange();
   \                     ??esp_event_loop_2:
   \   000021                ; Setup parameters for call to function esp_ProcessIdentifyTimeChange
   \   000021   12....       LCALL   ??esp_ProcessIdentifyTimeChange?relay
    662          
    663              return ( events ^ ESP_IDENTIFY_TIMEOUT_EVT );
   \   000024   EE           MOV     A,R6
   \   000025   6401         XRL     A,#0x1
   \                     ??esp_event_loop_3:
   \   000027   FA           MOV     R2,A
   \   000028   EF           MOV     A,R7
   \                     ??esp_event_loop_4:
   \   000029   FB           MOV     R3,A
   \   00002A   02....       LJMP    ??esp_event_loop_5 & 0xFFFF
    664            }
   \                     ??esp_event_loop_6:
   \   00002D                ; Setup parameters for call to function esp_ProcessZDOMsg
   \   00002D   12....       LCALL   ??esp_ProcessZDOMsg?relay
   \                     ??esp_event_loop_7:
   \   000030                ; Setup parameters for call to function osal_msg_deallocate
   \   000030   AA..         MOV     R2,?V0 + 0
   \   000032   AB..         MOV     R3,?V0 + 1
   \   000034   12....       LCALL   ??osal_msg_deallocate?relay
   \                     ??esp_event_loop_0:
   \   000037                ; Setup parameters for call to function osal_msg_receive
   \   000037   90....       MOV     DPTR,#espTaskID
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F9           MOV     R1,A
   \   00003C   12....       LCALL   ??osal_msg_receive?relay
   \   00003F   8A..         MOV     ?V0 + 0,R2
   \   000041   8B..         MOV     ?V0 + 1,R3
   \   000043   EA           MOV     A,R2
   \   000044   45..         ORL     A,?V0 + 1
   \   000046   602B         JZ      ??esp_event_loop_8
   \   000048   8A82         MOV     DPL,R2
   \   00004A   8B83         MOV     DPH,R3
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   24CC         ADD     A,#-0x34
   \   00004F   600A         JZ      ??esp_event_loop_9
   \   000051   2474         ADD     A,#0x74
   \   000053   600B         JZ      ??esp_event_loop_10
   \   000055   24ED         ADD     A,#-0x13
   \   000057   60D4         JZ      ??esp_event_loop_6
   \   000059   80D5         SJMP    ??esp_event_loop_7
   \                     ??esp_event_loop_9:
   \   00005B                ; Setup parameters for call to function esp_ProcessZCLMsg
   \   00005B   12....       LCALL   ??esp_ProcessZCLMsg?relay
   \   00005E   80D0         SJMP    ??esp_event_loop_7
   \                     ??esp_event_loop_10:
   \   000060                ; Setup parameters for call to function esp_HandleKeys
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   FA           MOV     R2,A
   \   000065   85..82       MOV     DPL,?V0 + 0
   \   000068   8B83         MOV     DPH,R3
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   F9           MOV     R1,A
   \   00006E   12....       LCALL   ??esp_HandleKeys?relay
   \   000071   80BD         SJMP    ??esp_event_loop_7
   \                     ??esp_event_loop_8:
   \   000073   EE           MOV     A,R6
   \   000074   FA           MOV     R2,A
   \   000075   EF           MOV     A,R7
   \   000076   6480         XRL     A,#0x80
   \   000078   80AF         SJMP    ??esp_event_loop_4
    665          
    666            // event to get current time
    667            if ( events & ESP_UPDATE_TIME_EVT )
   \                     ??esp_event_loop_1:
   \   00007A   5402         ANL     A,#0x2
   \   00007C   6011         JZ      ??esp_event_loop_11
    668            {
    669              espTime = osal_getClock();
   \   00007E                ; Setup parameters for call to function osal_getClock
   \   00007E   12....       LCALL   ??osal_getClock?relay
   \   000081   90....       MOV     DPTR,#espTime
   \   000084   12....       LCALL   ?XSTORE_R2345
    670              osal_start_timerEx( espTaskID, ESP_UPDATE_TIME_EVT, ESP_UPDATE_TIME_PERIOD );
   \   000087                ; Setup parameters for call to function osal_start_timerEx
   \   000087   12....       LCALL   ?Subroutine16 & 0xFFFF
    671          
    672              return ( events ^ ESP_UPDATE_TIME_EVT );
   \                     ??CrossCallReturnLabel_40:
   \   00008A   EE           MOV     A,R6
   \   00008B   6402         XRL     A,#0x2
   \                     ??esp_event_loop_12:
   \   00008D   8098         SJMP    ??esp_event_loop_3
    673            }
    674          
    675          
    676            // event to get simple descriptor of the newly joined device
    677            if ( events & SIMPLE_DESC_QUERY_EVT )
   \                     ??esp_event_loop_11:
   \   00008F   EE           MOV     A,R6
   \   000090   5404         ANL     A,#0x4
   \   000092   6022         JZ      ??esp_event_loop_13
    678            {
    679                ZDP_SimpleDescReq( &simpleDescReqAddr, simpleDescReqAddr.addr.shortAddr,
    680                                  ESP_ENDPOINT, 0);
   \   000094                ; Setup parameters for call to function ZDP_SimpleDescReq
   \   000094   75..00       MOV     ?V0 + 0,#0x0
   \   000097   78..         MOV     R0,#?V0 + 0
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009C   7909         MOV     R1,#0x9
   \   00009E   90....       MOV     DPTR,#simpleDescReqAddr
   \   0000A1   12....       LCALL   ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   0000A4   7A..         MOV     R2,#simpleDescReqAddr & 0xff
   \   0000A6   7B..         MOV     R3,#(simpleDescReqAddr >> 8) & 0xff
   \   0000A8   12....       LCALL   ??ZDP_SimpleDescReq?relay
   \   0000AB   7401         MOV     A,#0x1
   \   0000AD   12....       LCALL   ?DEALLOC_XSTACK8
    681          
    682                return ( events ^ SIMPLE_DESC_QUERY_EVT );
   \   0000B0   EE           MOV     A,R6
   \   0000B1   6404         XRL     A,#0x4
   \   0000B3   02....       LJMP    ??esp_event_loop_3 & 0xFFFF
    683            }
    684          
    685            // handle processing of timeout event triggered by request fast polling command
    686            if ( events & ESP_FAST_POLL_MODE_EVT )
   \                     ??esp_event_loop_13:
   \   0000B6   EE           MOV     A,R6
   \   0000B7   5408         ANL     A,#0x8
   \   0000B9   6016         JZ      ??esp_event_loop_14
    687            {
    688              if (espFastPollModeDuration)
   \   0000BB   90....       MOV     DPTR,#espFastPollModeDuration
   \   0000BE   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   0000C1   6009         JZ      ??CrossCallReturnLabel_0
    689              {
    690                espFastPollModeDuration--;
   \   0000C3   90....       MOV     DPTR,#espFastPollModeDuration
   \   0000C6   12....       LCALL   ?Subroutine17 & 0xFFFF
    691                // Start the timer for the fast poll period
    692                osal_start_timerEx( espTaskID, ESP_FAST_POLL_MODE_EVT, ESP_FAST_POLL_TIMER_PERIOD );
    693              }
   \                     ??CrossCallReturnLabel_28:
   \   0000C9   12....       LCALL   ?Subroutine4 & 0xFFFF
    694          
    695              return ( events ^ ESP_FAST_POLL_MODE_EVT );
   \                     ??CrossCallReturnLabel_0:
   \   0000CC   EE           MOV     A,R6
   \   0000CD   6408         XRL     A,#0x8
   \   0000CF   80BC         SJMP    ??esp_event_loop_12
    696            }
    697          
    698            // Discard unknown events
    699            return 0;
   \                     ??esp_event_loop_14:
   \   0000D1   7A00         MOV     R2,#0x0
   \   0000D3   7B00         MOV     R3,#0x0
   \                     ??esp_event_loop_5:
   \   0000D5                REQUIRE ?Subroutine1
   \   0000D5                ; // Fall through to label ?Subroutine1
    700          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   24FF         ADD     A,#-0x1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   34FF         ADDC    A,#-0x1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function osal_start_timerEx
   \   000001                ; Setup parameters for call to function osal_start_timerEx
   \   000001   7CE8         MOV     R4,#-0x18
   \   000003   7D03         MOV     R5,#0x3
   \   000005   7A08         MOV     R2,#0x8
   \   000007   7B00         MOV     R3,#0x0
   \   000009   90....       MOV     DPTR,#espTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   12....       LCALL   ??osal_start_timerEx?relay
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine30_0:
   \   000000   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000003   E8           MOV     A,R0
   \   000004   49           ORL     A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine36_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET
    701          
    702          /*********************************************************************
    703           * @fn      esp_ProcessAppMsg
    704           *
    705           * @brief   Process MT SYS APP MSG
    706           *
    707           * @param   msg - pointer to message
    708           *
    709           * @return  none
    710           */
    711          static void esp_ProcessAppMsg( uint8 *msg )
    712          {
    713            // user should include code to handle MT SYS APP MSG here
    714          }
    715          
    716          /*********************************************************************
    717           * @fn      esp_ProcessIdentifyTimeChange
    718           *
    719           * @brief   Called to blink led for specified IdentifyTime attribute value
    720           *
    721           * @param   none
    722           *
    723           * @return  none
    724           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    725          static void esp_ProcessIdentifyTimeChange( void )
   \                     esp_ProcessIdentifyTimeChange:
    726          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    727            if ( espIdentifyTime > 0 )
   \   000004   90....       MOV     DPTR,#espIdentifyTime
   \   000007   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   00000A   6018         JZ      ??esp_ProcessIdentifyTimeChange_0
    728            {
    729              osal_start_timerEx( espTaskID, ESP_IDENTIFY_TIMEOUT_EVT, 1000 );
   \   00000C                ; Setup parameters for call to function osal_start_timerEx
   \   00000C   7CE8         MOV     R4,#-0x18
   \   00000E   7D03         MOV     R5,#0x3
   \   000010   7A01         MOV     R2,#0x1
   \   000012   12....       LCALL   ??Subroutine26_0 & 0xFFFF
    730              HalLedBlink ( HAL_LED_4, 0xFF, HAL_LED_DEFAULT_DUTY_CYCLE, HAL_LED_DEFAULT_FLASH_TIME );
   \                     ??CrossCallReturnLabel_41:
   \   000015                ; Setup parameters for call to function HalLedBlink
   \   000015   7CE8         MOV     R4,#-0x18
   \   000017   7D03         MOV     R5,#0x3
   \   000019   7B05         MOV     R3,#0x5
   \   00001B   7AFF         MOV     R2,#-0x1
   \   00001D   7908         MOV     R1,#0x8
   \   00001F   12....       LCALL   ??HalLedBlink?relay
   \   000022   8013         SJMP    ??esp_ProcessIdentifyTimeChange_1
    731            }
    732            else
    733            {
    734              HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \                     ??esp_ProcessIdentifyTimeChange_0:
   \   000024                ; Setup parameters for call to function HalLedSet
   \   000024   7A00         MOV     R2,#0x0
   \   000026   7908         MOV     R1,#0x8
   \   000028   12....       LCALL   ??HalLedSet?relay
    735              osal_stop_timerEx( espTaskID, ESP_IDENTIFY_TIMEOUT_EVT );
   \   00002B                ; Setup parameters for call to function osal_stop_timerEx
   \   00002B   7A01         MOV     R2,#0x1
   \   00002D   7B00         MOV     R3,#0x0
   \   00002F   90....       MOV     DPTR,#espTaskID
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F9           MOV     R1,A
   \   000034   12....       LCALL   ??osal_stop_timerEx?relay
    736            }
    737          }
   \                     ??esp_ProcessIdentifyTimeChange_1:
   \   000037   02....       LJMP    ?Subroutine2 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    738          
    739          
    740          /*********************************************************************
    741           * @fn      esp_HandleKeys
    742           *
    743           * @brief   Handles all key events for this device.
    744           *
    745           * @param   shift - true if in shift/alt.
    746           * @param   keys - bit field for key events. Valid entries:
    747           *                 HAL_KEY_SW_4
    748           *                 HAL_KEY_SW_3
    749           *                 HAL_KEY_SW_2
    750           *                 HAL_KEY_SW_1
    751           *
    752           * @return  none
    753           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    754          static void esp_HandleKeys( uint8 shift, uint8 keys )
   \                     esp_HandleKeys:
    755          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 35
   \   000005   74DD         MOV     A,#-0x23
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   EA           MOV     A,R2
   \   00000D   FF           MOV     R7,A
    756            // Shift is used to make each button/switch dual purpose.
    757            if ( shift )
   \   00000E   EE           MOV     A,R6
   \   00000F   6003         JZ      $+5
   \   000011   02....       LJMP    ??esp_HandleKeys_0 & 0xFFFF
    758            {
    759              if ( keys & HAL_KEY_SW_1 )
    760              {
    761              }
    762              if ( keys & HAL_KEY_SW_2 )
    763              {
    764              }
    765              if ( keys & HAL_KEY_SW_3 )
    766              {
    767              }
    768              if ( keys & HAL_KEY_SW_4 )
    769              {
    770              }
    771            }
    772            else
    773            {
    774              if ( keys & HAL_KEY_SW_1 )
   \   000014   EF           MOV     A,R7
   \   000015   A2E0         MOV     C,0xE0 /* A   */.0
   \   000017   502E         JNC     ??esp_HandleKeys_1
    775              {
    776                // send out cooling event to PCT
    777                loadControlCmd.deviceGroupClass = HVAC_DEVICE_CLASS; // HVAC compressor or furnace - bit 0 is set
   \   000019   90....       MOV     DPTR,#__Constant_1
   \   00001C   12....       LCALL   ?XLOAD_R2345
   \   00001F   90....       MOV     DPTR,#loadControlCmd + 4
   \   000022   12....       LCALL   ?XSTORE_R2345
    778                zclSE_LoadControl_Send_LoadControlEvent( ESP_ENDPOINT, &pctAddr, &loadControlCmd, TRUE, 0 );
   \   000025                ; Setup parameters for call to function zclSE_LoadControl_Send_LoadControlEvent
   \   000025   75..00       MOV     ?V0 + 0,#0x0
   \   000028   78..         MOV     R0,#?V0 + 0
   \   00002A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00002D   75..01       MOV     ?V0 + 0,#0x1
   \   000030   78..         MOV     R0,#?V0 + 0
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000035   7C..         MOV     R4,#loadControlCmd & 0xff
   \   000037   7D..         MOV     R5,#(loadControlCmd >> 8) & 0xff
   \   000039   7A..         MOV     R2,#pctAddr & 0xff
   \   00003B   7B..         MOV     R3,#(pctAddr >> 8) & 0xff
   \   00003D   7909         MOV     R1,#0x9
   \   00003F   12....       LCALL   ??zclSE_LoadControl_Send_LoadControlEvent?relay
   \   000042   7402         MOV     A,#0x2
   \   000044   12....       LCALL   ?DEALLOC_XSTACK8
    779              }
    780          
    781              if ( keys & HAL_KEY_SW_2 )
   \                     ??esp_HandleKeys_1:
   \   000047   EF           MOV     A,R7
   \   000048   A2E1         MOV     C,0xE0 /* A   */.1
   \   00004A   502E         JNC     ??esp_HandleKeys_2
    782              {
    783                // send out load control event to load control device
    784                loadControlCmd.deviceGroupClass = ONOFF_LOAD_DEVICE_CLASS; // simple misc residential on/off loads - bit 7 is set
   \   00004C   90....       MOV     DPTR,#__Constant_80
   \   00004F   12....       LCALL   ?XLOAD_R2345
   \   000052   90....       MOV     DPTR,#loadControlCmd + 4
   \   000055   12....       LCALL   ?XSTORE_R2345
    785                zclSE_LoadControl_Send_LoadControlEvent( ESP_ENDPOINT, &loadControlAddr, &loadControlCmd, TRUE, 0 );
   \   000058                ; Setup parameters for call to function zclSE_LoadControl_Send_LoadControlEvent
   \   000058   75..00       MOV     ?V0 + 0,#0x0
   \   00005B   78..         MOV     R0,#?V0 + 0
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000060   75..01       MOV     ?V0 + 0,#0x1
   \   000063   78..         MOV     R0,#?V0 + 0
   \   000065   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000068   7C..         MOV     R4,#loadControlCmd & 0xff
   \   00006A   7D..         MOV     R5,#(loadControlCmd >> 8) & 0xff
   \   00006C   7A..         MOV     R2,#loadControlAddr & 0xff
   \   00006E   7B..         MOV     R3,#(loadControlAddr >> 8) & 0xff
   \   000070   7909         MOV     R1,#0x9
   \   000072   12....       LCALL   ??zclSE_LoadControl_Send_LoadControlEvent?relay
   \   000075   7402         MOV     A,#0x2
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
    786              }
    787          
    788              if ( keys & HAL_KEY_SW_3 )
   \                     ??esp_HandleKeys_2:
   \   00007A   EF           MOV     A,R7
   \   00007B   A2E4         MOV     C,0xE0 /* A   */.4
   \   00007D   5053         JNC     ??esp_HandleKeys_0
    789              {
    790                zclCCDisplayMessage_t displayCmd;             // command structure for message being sent to in premise display
    791          
    792                // Define to zero to send the TI IPD message, non-zero to send a string of abc's.
    793          #if   !defined IPD_MSG_SZ
    794                #define  IPD_MSG_SZ  0
    795          #endif
    796          #if   (IPD_MSG_SZ == 0)
    797                uint8 msgBuf[]="TI IPD Test Msg!";
   \   00007F   7412         MOV     A,#0x12
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   AC82         MOV     R4,DPL
   \   000086   AD83         MOV     R5,DPH
   \   000088   7583..       MOV     DPH,#(`?<Constant "TI IPD Test Msg!">` >> 8) & 0xff
   \   00008B   7582..       MOV     DPL,#`?<Constant "TI IPD Test Msg!">` & 0xff
   \   00008E   7411         MOV     A,#0x11
   \   000090   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    798                const uint8 msgLen = sizeof(msgBuf);
    799          #else
    800                uint8 *msgBuf = osal_mem_alloc(IPD_MSG_SZ);
    801                const uint8 msgLen = IPD_MSG_SZ;
    802                uint8 idx;
    803          
    804                if (!msgBuf)  return;
    805          
    806                for (idx = 0; idx < msgLen; idx ++)
    807                {
    808                  msgBuf[idx] = 'a' + idx % 26;
    809                }
    810          #endif
    811          
    812                displayCmd.msgString.strLen = msgLen;
   \   000093   740F         MOV     A,#0xf
   \   000095   12....       LCALL   ?XSTACK_DISP0_8
   \   000098   7411         MOV     A,#0x11
   \   00009A   F0           MOVX    @DPTR,A
    813                displayCmd.msgString.pStr = msgBuf;
   \   00009B   04           INC     A
   \   00009C   12....       LCALL   ?XSTACK_DISP0_8
   \   00009F   A882         MOV     R0,DPL
   \   0000A1   A983         MOV     R1,DPH
   \   0000A3   7410         MOV     A,#0x10
   \   0000A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A8   12....       LCALL   ?Subroutine7 & 0xFFFF
    814          
    815                zclSE_Message_Send_DisplayMessage( ESP_ENDPOINT, &ipdAddr, &displayCmd, TRUE, 0 );
   \                     ??CrossCallReturnLabel_6:
   \   0000AB                ; Setup parameters for call to function zclSE_Message_Send_DisplayMessage
   \   0000AB   75..00       MOV     ?V0 + 0,#0x0
   \   0000AE   78..         MOV     R0,#?V0 + 0
   \   0000B0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B3   75..01       MOV     ?V0 + 0,#0x1
   \   0000B6   78..         MOV     R0,#?V0 + 0
   \   0000B8   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BB   7402         MOV     A,#0x2
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   AC82         MOV     R4,DPL
   \   0000C2   AD83         MOV     R5,DPH
   \   0000C4   7A..         MOV     R2,#ipdAddr & 0xff
   \   0000C6   7B..         MOV     R3,#(ipdAddr >> 8) & 0xff
   \   0000C8   7909         MOV     R1,#0x9
   \   0000CA   12....       LCALL   ??zclSE_Message_Send_DisplayMessage?relay
   \   0000CD   7402         MOV     A,#0x2
   \   0000CF   12....       LCALL   ?DEALLOC_XSTACK8
    816          
    817          #if   (IPD_MSG_SZ != 0)
    818                osal_mem_free(msgBuf);
    819          #endif
    820              }
    821          
    822              if ( keys & HAL_KEY_SW_4 )
    823              {
    824          
    825              }
    826            }
    827          }
   \                     ??esp_HandleKeys_0:
   \   0000D2   7423         MOV     A,#0x23
   \   0000D4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D7   7F01         MOV     R7,#0x1
   \   0000D9   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    828          
    829          /*********************************************************************
    830           * @fn      esp_ValidateAttrDataCB
    831           *
    832           * @brief   Check to see if the supplied value for the attribute data
    833           *          is within the specified range of the attribute.
    834           *
    835           *
    836           * @param   pAttr - pointer to attribute
    837           * @param   pAttrInfo - pointer to attribute info
    838           *
    839           * @return  TRUE if data valid. FALSE otherwise.
    840           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    841          static uint8 esp_ValidateAttrDataCB( zclAttrRec_t *pAttr, zclWriteRec_t *pAttrInfo )
   \                     esp_ValidateAttrDataCB:
    842          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    843            uint8 valid = TRUE;
   \   000004   7901         MOV     R1,#0x1
    844          
    845            switch ( pAttrInfo->dataType )
   \   000006   8C82         MOV     DPL,R4
   \   000008   8D83         MOV     DPH,R5
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6410         XRL     A,#0x10
   \   00000F   7025         JNZ     ??esp_ValidateAttrDataCB_0
    846            {
    847              case ZCL_DATATYPE_BOOLEAN:
    848                if ( ( *(pAttrInfo->attrData) != 0 ) && ( *(pAttrInfo->attrData) != 1 ) )
   \   000011   8C82         MOV     DPL,R4
   \   000013   8D83         MOV     DPH,R5
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F8           MOV     R0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F583         MOV     DPH,A
   \   00001E   8882         MOV     DPL,R0
   \   000020   E0           MOVX    A,@DPTR
   \   000021   6013         JZ      ??esp_ValidateAttrDataCB_0
   \   000023   8C82         MOV     DPL,R4
   \   000025   8D83         MOV     DPH,R5
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F583         MOV     DPH,A
   \   00002E   8882         MOV     DPL,R0
   \   000030   E0           MOVX    A,@DPTR
   \   000031   6401         XRL     A,#0x1
   \   000033   6001         JZ      ??esp_ValidateAttrDataCB_0
    849                {
    850                  valid = FALSE;
   \   000035   19           DEC     R1
    851                }
    852                break;
    853          
    854              default:
    855                break;
    856            }
    857          
    858            return ( valid );
   \                     ??esp_ValidateAttrDataCB_0:
   \   000036   80..         SJMP    ?Subroutine2
    859          }
    860          
    861          /*********************************************************************
    862           * @fn      esp_BasicResetCB
    863           *
    864           * @brief   Callback from the ZCL General Cluster Library to set all
    865           *          the attributes of all the clusters to their factory defaults
    866           *
    867           * @param   none
    868           *
    869           * @return  none
    870           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    871          static void esp_BasicResetCB( void )
   \                     esp_BasicResetCB:
    872          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    873            // user should handle setting attributes to factory defaults here
    874          }
   \   000000   02....       LJMP    ?BRET
    875          
    876          /*********************************************************************
    877           * @fn      esp_IdentifyCB
    878           *
    879           * @brief   Callback from the ZCL General Cluster Library when
    880           *          it received an Identify Command for this application.
    881           *
    882           * @param   pCmd - pointer to structure for Identify command
    883           *
    884           * @return  none
    885           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    886          static void esp_IdentifyCB( zclIdentify_t *pCmd )
   \                     esp_IdentifyCB:
    887          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    888            espIdentifyTime = pCmd->identifyTime;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00000B   90....       MOV     DPTR,#espIdentifyTime
   \   00000E   12....       LCALL   ?Subroutine7 & 0xFFFF
    889            esp_ProcessIdentifyTimeChange();
   \                     ??CrossCallReturnLabel_7:
   \   000011                ; Setup parameters for call to function esp_ProcessIdentifyTimeChange
   \   000011   12....       LCALL   ??esp_ProcessIdentifyTimeChange?relay
    890          }
   \   000014                REQUIRE ?Subroutine2
   \   000014                ; // Fall through to label ?Subroutine2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine28_0
   \   000001                ; // Fall through to label ??Subroutine28_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine29_0
   \   000001                ; // Fall through to label ??Subroutine29_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine29_0:
   \   000000   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000003   22           RET
    891          
    892          /*********************************************************************
    893           * @fn      esp_IdentifyQueryRspCB
    894           *
    895           * @brief   Callback from the ZCL General Cluster Library when
    896           *          it received an Identity Query Response Command for this application.
    897           *
    898           * @param   pRsp - pointer to structure for Identity Query Response command
    899           *
    900           * @return  none
    901           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    902          static void esp_IdentifyQueryRspCB( zclIdentifyQueryRsp_t *pRsp )
   \                     esp_IdentifyQueryRspCB:
    903          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    904            // add user code here
    905          }
   \   000000   02....       LJMP    ?BRET
    906          
    907          /*********************************************************************
    908           * @fn      esp_AlarmCB
    909           *
    910           * @brief   Callback from the ZCL General Cluster Library when
    911           *          it received an Alam request or response command for
    912           *          this application.
    913           *
    914           * @param   pAlarm - pointer to structure for Alarm command
    915           *
    916           * @return  none
    917           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    918          static void esp_AlarmCB( zclAlarm_t *pAlarm )
   \                     esp_AlarmCB:
    919          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    920            // add user code here
    921          }
   \   000000   02....       LJMP    ?BRET
    922          
    923          #ifdef SE_UK_EXT
    924          /*********************************************************************
    925           * @fn      esp_GetEventLogCB
    926           *
    927           * @brief   Callback from the ZCL General Cluster Library when
    928           *          it received a Get Event Log command for this
    929           *          application.
    930           *
    931           * @param   srcEP - source endpoint
    932           * @param   srcAddr - pointer to source address
    933           * @param   pEventLog - pointer to structure for Get Event Log command
    934           * @param   seqNum - sequence number of this command
    935           *
    936           * @return  none
    937           */
    938          static void esp_GetEventLogCB( uint8 srcEP, afAddrType_t *srcAddr,
    939                                         zclGetEventLog_t *pEventLog, uint8 seqNum )
    940          {
    941            // add user code here, which could fragment the event log payload if
    942            // the entire payload doesn't fit into one Publish Event Log Command.
    943            // Note: the Command Index starts at 0 and is incremented for each
    944            // fragment belonging to the same command.
    945          
    946            // There's no event log for now! The Metering Device will support
    947            // logging for all events configured to do so.
    948          }
    949          
    950          /*********************************************************************
    951           * @fn      esp_PublishEventLogCB
    952           *
    953           * @brief   Callback from the ZCL General Cluster Library when
    954           *          it received a Publish Event Log command for this
    955           *          application.
    956           *
    957           * @param   srcAddr - pointer to source address
    958           * @param   pEventLog - pointer to structure for Publish Event Log command
    959           *
    960           * @return  none
    961           */
    962          static void esp_PublishEventLogCB( afAddrType_t *srcAddr, zclPublishEventLog_t *pEventLog )
    963          {
    964            // add user code here
    965          }
    966          #endif // SE_UK_EXT
    967          
    968          /*********************************************************************
    969           * @fn      esp_GetProfileCmdCB
    970           *
    971           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
    972           *          it received a Get Profile Command for
    973           *          this application.
    974           *
    975           * @param   pCmd - pointer to structure for Get Profile command
    976           * @param   srcAddr - pointer to source address
    977           * @param   seqNum - sequence number of this command
    978           *
    979           * @return  none
    980           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    981          static void esp_GetProfileCmdCB( zclCCGetProfileCmd_t *pCmd,
   \                     esp_GetProfileCmdCB:
    982                                           afAddrType_t *srcAddr, uint8 seqNum )
    983          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   EC           MOV     A,R4
   \   00000F   FA           MOV     R2,A
   \   000010   ED           MOV     A,R5
   \   000011   FB           MOV     R3,A
    984          #if defined ( ZCL_SIMPLE_METERING )
    985            // Upon receipt of the Get Profile Command, the metering device shall send
    986            // Get Profile Response back.
    987          
    988            // Variables in the following are initialized to arbitrary value for test purpose
    989            // In real application, user shall look up the interval data captured during
    990            // the period specified in the pCmd->endTime and return corresponding data.
    991          
    992            uint32 endTime;
    993            uint8  status = zclSE_SimpleMeter_GetProfileRsp_Status_Success;
    994            uint8  profileIntervalPeriod = PROFILE_INTERVAL_PERIOD_60MIN;
    995            uint8  numberOfPeriodDelivered = 5;
    996            uint24 intervals[] = {0xa00001, 0xa00002, 0xa00003, 0xa00004, 0xa00005};
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   7583..       MOV     DPH,#(`?<Constant {10485761L, 10485762L, 10485763L, 1` >> 8) & 0xff
   \   00001F   7582..       MOV     DPL,#`?<Constant {10485761L, 10485762L, 10485763L, 1` & 0xff
   \   000022   7414         MOV     A,#0x14
   \   000024   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    997          
    998            // endTime: 32 bit value (in UTC) representing the end time of the most
    999            // chronologically recent interval being requested.
   1000            // Example: Data collected from 2:00 PM to 3:00 PM would be specified as a
   1001            // 3:00 PM interval (end time).
   1002          
   1003            // The Intervals block returned shall be the most recent block with
   1004            // its EndTime equal or older to the one in the request (pCmd->endTime).
   1005            // Requested End Time with value 0xFFFFFFFF indicats the most recent
   1006            // Intervals block is requested.
   1007          
   1008            // Sample Code - assuming the end time of the requested block is the same as
   1009            // it in the request.
   1010            endTime = pCmd->endTime;
   1011          
   1012            // Send Get Profile Response Command back
   1013          
   1014            zclSE_SimpleMetering_Send_GetProfileRsp( ESP_ENDPOINT, srcAddr, endTime,
   1015                                                     status,
   1016                                                     profileIntervalPeriod,
   1017                                                     numberOfPeriodDelivered, intervals,
   1018                                                     FALSE, seqNum );
   \   000027                ; Setup parameters for call to function zclSE_SimpleMetering_Send_GetProfileRsp
   \   000027   E9           MOV     A,R1
   \   000028   F5..         MOV     ?V0 + 0,A
   \   00002A   78..         MOV     R0,#?V0 + 0
   \   00002C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00002F   75..00       MOV     ?V0 + 0,#0x0
   \   000032   78..         MOV     R0,#?V0 + 0
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   8582..       MOV     ?V0 + 0,DPL
   \   00003F   8583..       MOV     ?V0 + 1,DPH
   \   000042   78..         MOV     R0,#?V0 + 0
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000047   75..05       MOV     ?V0 + 0,#0x5
   \   00004A   78..         MOV     R0,#?V0 + 0
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004F   8E82         MOV     DPL,R6
   \   000051   8F83         MOV     DPH,R7
   \   000053   A3           INC     DPTR
   \   000054   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   000057   7D01         MOV     R5,#0x1
   \   000059   7C00         MOV     R4,#0x0
   \   00005B   7909         MOV     R1,#0x9
   \   00005D   12....       LCALL   ??zclSE_SimpleMetering_Send_GetProfileRsp?relay
   \   000060   7409         MOV     A,#0x9
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
   1019          #endif // ZCL_SIMPLE_METERING
   1020          }
   \   000065   7414         MOV     A,#0x14
   \   000067   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006A   7F03         MOV     R7,#0x3
   \   00006C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1021          
   1022          /*********************************************************************
   1023           * @fn      esp_GetProfileRspCB
   1024           *
   1025           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1026           *          it received a Get Profile Response for
   1027           *          this application.
   1028           *
   1029           * @param   pCmd - pointer to structure for Get Profile Response command
   1030           * @param   srcAddr - pointer to source address
   1031           * @param   seqNum - sequence number of this command
   1032           *
   1033           * @return  none
   1034           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1035          static void esp_GetProfileRspCB( zclCCGetProfileRsp_t *pCmd,
   \                     esp_GetProfileRspCB:
   1036                                           afAddrType_t *srcAddr, uint8 seqNum )
   1037          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1038            // add user code here
   1039          }
   \   000000   02....       LJMP    ?BRET
   1040          
   1041          /*********************************************************************
   1042           * @fn      esp_ReqMirrorCmdCB
   1043           *
   1044           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1045           *          it received a Request Mirror Command for
   1046           *          this application.
   1047           *
   1048           * @param   srcAddr - pointer to source address
   1049           * @param   seqNum - sequence number of this command
   1050           *
   1051           * @return  none
   1052           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1053          static void esp_ReqMirrorCmdCB( afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_ReqMirrorCmdCB:
   1054          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1055          #if defined ( ZCL_SIMPLE_METERING )
   1056          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
   1057            uint8 endpoint;
   1058          
   1059            // See if a mirror exists for the given source address and endpoint
   1060            endpoint = esp_GetMirrorEndpoint( srcAddr );
   1061          
   1062            if ( endpoint == ESP_MIRROR_INVALID_ENDPOINT )
   1063            {
   1064              // No endpoint exists.  Try allocating one.
   1065              endpoint = esp_AllocMirror(srcAddr);
   1066          
   1067              if (endpoint != ESP_MIRROR_INVALID_ENDPOINT)
   1068              {
   1069                // Setup endpoint
   1070                espMirrorInfo_t *pInfo = esp_GetMirrorInfo(endpoint);
   1071          
   1072                if ( pInfo != NULL )
   1073                {
   1074                  // Create a simple descriptor for the mirror
   1075                  SimpleDescriptionFormat_t *pMirrorSimpleDesc = osal_mem_alloc( sizeof( SimpleDescriptionFormat_t ) );
   1076          
   1077                  if ( pMirrorSimpleDesc != NULL )
   1078                  {
   1079                    zclAttrRec_t *pAttr = pInfo->pAttr;
   1080          
   1081                    pMirrorSimpleDesc->EndPoint = endpoint;
   1082                    pMirrorSimpleDesc->AppProfId = ZCL_SE_PROFILE_ID;
   1083                    pMirrorSimpleDesc->AppDeviceId = ZCL_SE_DEVICEID_METER;
   1084                    pMirrorSimpleDesc->AppDevVer = MIRROR_DEVICE_VERSION;
   1085                    pMirrorSimpleDesc->Reserved = MIRROR_FLAGS;
   1086                    pMirrorSimpleDesc->AppNumInClusters = MIRROR_MAX_INCLUSTERS;
   1087                    pMirrorSimpleDesc->pAppInClusterList = (cId_t *) mirrorInClusterList;
   1088                    pMirrorSimpleDesc->AppNumOutClusters = MIRROR_MAX_OUTCLUSTERS;
   1089                    pMirrorSimpleDesc->pAppOutClusterList = (cId_t *) mirrorOutClusterList;
   1090          
   1091                    zclSE_Init( pMirrorSimpleDesc );
   1092          
   1093                    // Register the attribute list
   1094                    zcl_registerAttrList( endpoint, ESP_MIRROR_MAX_ATTRIBUTES, (CONST zclAttrRec_t *) pAttr );
   1095                  }
   1096                  else
   1097                  {
   1098                    esp_FreeMirror( endpoint );
   1099                    endpoint = ESP_MIRROR_INVALID_ENDPOINT;
   1100                  }
   1101                }
   1102              }
   1103            }
   1104          
   1105            if ( endpoint != ESP_MIRROR_INVALID_ENDPOINT )
   1106            {
   1107              // Send response to the peer with the mirror endpoint ID
   1108              zclSE_SimpleMetering_Send_ReqMirrorRsp( ESP_ENDPOINT, srcAddr, endpoint, TRUE, seqNum );
   1109            }
   1110            else
   1111            {
   1112              // Send response indicating we cannot create the mirror
   1113              zclSE_SimpleMetering_Send_ReqMirrorRsp(ESP_ENDPOINT, srcAddr, 0xFFFF, TRUE, seqNum);
   1114            }
   1115          #endif  // SE_UK_EXT && SE_MIRROR
   1116          #endif  // ZCL_SIMPLE_METERING
   1117          }
   \   000000   02....       LJMP    ?BRET
   1118          /*********************************************************************
   1119           * @fn      esp_ReqMirrorRspCB
   1120           *
   1121           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1122           *          it received a Request Mirror Response for
   1123           *          this application.
   1124           *
   1125           * @param   pCmd - pointer to structure for Request Mirror Response command
   1126           * @param   srcAddr - pointer to source address
   1127           * @param   seqNum - sequence number of this command
   1128           *
   1129           * @return  none
   1130           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1131          static void esp_ReqMirrorRspCB( zclCCReqMirrorRsp_t *pCmd,
   \                     esp_ReqMirrorRspCB:
   1132                                          afAddrType_t *srcAddr, uint8 seqNum )
   1133          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1134            // add user code here
   1135          }
   \   000000   02....       LJMP    ?BRET
   1136          
   1137          /*********************************************************************
   1138           * @fn      esp_MirrorRemCmdCB
   1139           *
   1140           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1141           *          it received a Mirror Remove Command for
   1142           *          this application.
   1143           *
   1144           * @param   srcAddr - pointer to source address
   1145           * @param   seqNum - sequence number of this command
   1146           *
   1147           * @return  none
   1148           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1149          static void esp_MirrorRemCmdCB( afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_MirrorRemCmdCB:
   1150          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1151          #if defined ( ZCL_SIMPLE_METERING )
   1152          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
   1153            // Check if this is a valid endpoint for a mirror
   1154            uint8 endpoint = esp_GetMirrorEndpoint( srcAddr );
   1155          
   1156            if ( endpoint != ESP_MIRROR_INVALID_ENDPOINT )
   1157            {
   1158              // Set the PhysicalEnvironment attribute indicating a mirror slot is available
   1159              espPhysicalEnvironment |= PHY_MIRROR_CAPACITY_ENV;
   1160          
   1161              endPointDesc_t *epDesc = afFindEndPointDesc( endpoint );
   1162          
   1163              // Free memory allocated for SimpleDescriptor in esp_ReqMirrorCmdCB()
   1164              if ( epDesc->simpleDesc != NULL )
   1165              {
   1166                osal_mem_free( epDesc->simpleDesc );
   1167              }
   1168          
   1169              // Delete endpoint completely
   1170              afDelete( endpoint );
   1171          
   1172              // Free the mirror in the mirror control block
   1173              esp_FreeMirror( endpoint );
   1174          
   1175              // Send response to peer
   1176              zclSE_SimpleMetering_Send_RemMirrorRsp( ESP_ENDPOINT, srcAddr, endpoint, TRUE, seqNum );
   1177            }
   1178            else
   1179            {
   1180              // The specification does not state how to deal with the case where no mirror exists,
   1181              // For now, send 0xFFFF in the endpoint.
   1182              zclSE_SimpleMetering_Send_RemMirrorRsp( ESP_ENDPOINT, srcAddr, 0xFFFF, TRUE, seqNum );
   1183            }
   1184          #endif  // SE_UK_EXT && SE_MIRROR
   1185          #endif  // ZCL_SIMPLE_METERING
   1186          }
   \   000000   02....       LJMP    ?BRET
   1187          
   1188          /*********************************************************************
   1189           * @fn      esp_MirrorRemRspCB
   1190           *
   1191           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1192           *          it received a Mirror Remove Response for
   1193           *          this application.
   1194           *
   1195           * @param   pCmd - pointer to structure for Mirror Remove Response command
   1196           * @param   srcAddr - pointer to source address
   1197           * @param   seqNum - sequence number of this command
   1198           *
   1199           * @return  none
   1200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1201          static void esp_MirrorRemRspCB( zclCCMirrorRemRsp_t *pCmd,
   \                     esp_MirrorRemRspCB:
   1202                                          afAddrType_t *srcAddr, uint8 seqNum )
   1203          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1204            // add user code here
   1205          }
   \   000000   02....       LJMP    ?BRET
   1206          
   1207          /*********************************************************************
   1208           * @fn      esp_ReqFastPollModeCmdCB
   1209           *
   1210           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1211           *          it received a Request Fast Poll Mode Command for
   1212           *          this application.
   1213           *
   1214           * @param   pCmd - pointer to structure for Request Fast Poll Mode command
   1215           * @param   srcAddr - pointer to source address
   1216           * @param   seqNum - sequence number of this command
   1217           *
   1218           * @return  none
   1219           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1220          static void esp_ReqFastPollModeCmdCB( zclCCReqFastPollModeCmd_t *pCmd, afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_ReqFastPollModeCmdCB:
   1221          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 5
   \   000005   74FB         MOV     A,#-0x5
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V0 + 12,R4
   \   00000C   8D..         MOV     ?V0 + 13,R5
   \   00000E   E9           MOV     A,R1
   \   00000F   FE           MOV     R6,A
   1222          #if defined ( ZCL_SIMPLE_METERING )
   1223            if ( pCmd != NULL )
   \   000010   EA           MOV     A,R2
   \   000011   4B           ORL     A,R3
   \   000012   7003         JNZ     $+5
   \   000014   02....       LJMP    ??esp_ReqFastPollModeCmdCB_0 & 0xFFFF
   1224            {
   1225              zclCCReqFastPollModeRsp_t fastPollRsp;
   1226              UTCTime utcSecs;
   1227          
   1228              if (pCmd->fastPollUpdatePeriod < espFastPollUpdatePeriod)
   \   000017   90....       MOV     DPTR,#espFastPollUpdatePeriod
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F8           MOV     R0,A
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \   000020   E0           MOVX    A,@DPTR
   \   000021   C3           CLR     C
   \   000022   98           SUBB    A,R0
   \   000023   5003         JNC     ??esp_ReqFastPollModeCmdCB_1
   1229              {
   1230                // handles client requests for a fast poll rate that is less than the
   1231                // value of the its FastPollUpdateRate attribute
   1232                fastPollRsp.appliedUpdatePeriod = espFastPollUpdatePeriod;
   \   000025   90....       MOV     DPTR,#espFastPollUpdatePeriod
   1233              }
   1234              else
   1235              {
   1236                fastPollRsp.appliedUpdatePeriod = pCmd->fastPollUpdatePeriod;
   \                     ??esp_ReqFastPollModeCmdCB_1:
   \   000028   E0           MOVX    A,@DPTR
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   12....       LCALL   ?Subroutine6 & 0xFFFF
   1237              }
   1238          
   1239              if ((espFastPollModeDuration == 0) && (pCmd->duration > 0))
   \                     ??CrossCallReturnLabel_4:
   \   000032   49           ORL     A,R1
   \   000033   703B         JNZ     ??CrossCallReturnLabel_1
   \   000035   8A82         MOV     DPL,R2
   \   000037   8B83         MOV     DPH,R3
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   6033         JZ      ??CrossCallReturnLabel_1
   1240              {
   1241                if (pCmd->duration > MAX_DURATION_IN_MINUTES_FAST_POLL_MODE)
   \   00003D   C3           CLR     C
   \   00003E   9410         SUBB    A,#0x10
   \   000040   4007         JC      ??esp_ReqFastPollModeCmdCB_2
   1242                {
   1243                  // handles client requests for duration that is greater than the
   1244                  // maximum allowable 15 minutes.
   1245                  espFastPollModeDuration = MAX_DURATION_IN_MINUTES_FAST_POLL_MODE;
   \   000042   90....       MOV     DPTR,#espFastPollModeDuration
   \   000045   740F         MOV     A,#0xf
   \   000047   8009         SJMP    ??esp_ReqFastPollModeCmdCB_3
   1246                }
   1247                else
   1248                {
   1249                  espFastPollModeDuration = pCmd->duration;
   \                     ??esp_ReqFastPollModeCmdCB_2:
   \   000049   8A82         MOV     DPL,R2
   \   00004B   8B83         MOV     DPH,R3
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   90....       MOV     DPTR,#espFastPollModeDuration
   \                     ??esp_ReqFastPollModeCmdCB_3:
   \   000052   F0           MOVX    @DPTR,A
   \   000053   A3           INC     DPTR
   \   000054   E4           CLR     A
   1250                }
   1251          
   1252                // This controls the counter for ZCLTESTAPP_FAST_POLL_MODE_EVT based on a 1 second timer
   1253                espFastPollModeDuration *= 60;  // Duration in seconds
   1254          
   1255                // Start the timer for the fast poll period
   1256                osal_start_timerEx( espTaskID, ESP_FAST_POLL_MODE_EVT, ESP_FAST_POLL_TIMER_PERIOD );
   1257              }
   \   000055   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000058   75F03C       MOV     B,#0x3c
   \   00005B   A4           MUL     AB
   \   00005C   F8           MOV     R0,A
   \   00005D   AAF0         MOV     R2,B
   \   00005F   75F03C       MOV     B,#0x3c
   \   000062   E9           MOV     A,R1
   \   000063   A4           MUL     AB
   \   000064   2A           ADD     A,R2
   \   000065   F9           MOV     R1,A
   \   000066   90....       MOV     DPTR,#espFastPollModeDuration
   \   000069   E8           MOV     A,R0
   \   00006A   F0           MOVX    @DPTR,A
   \   00006B   A3           INC     DPTR
   \   00006C   E9           MOV     A,R1
   \   00006D   12....       LCALL   ?Subroutine4 & 0xFFFF
   1258          
   1259              // get UTC time and update with requested duration in seconds
   1260              utcSecs = osal_getClock();
   \                     ??CrossCallReturnLabel_1:
   \   000070                ; Setup parameters for call to function osal_getClock
   \   000070   12....       LCALL   ??osal_getClock?relay
   \   000073   8A..         MOV     ?V0 + 4,R2
   \   000075   8B..         MOV     ?V0 + 5,R3
   1261              fastPollRsp.fastPollModeEndTime = utcSecs + espFastPollModeDuration;
   \   000077   8A..         MOV     ?V0 + 0,R2
   \   000079   8B..         MOV     ?V0 + 1,R3
   \   00007B   8C..         MOV     ?V0 + 2,R4
   \   00007D   8D..         MOV     ?V0 + 3,R5
   \   00007F   90....       MOV     DPTR,#espFastPollModeDuration
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F5..         MOV     ?V0 + 8,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   F5..         MOV     ?V0 + 9,A
   \   000089   E4           CLR     A
   \   00008A   F5..         MOV     ?V0 + 10,A
   \   00008C   F5..         MOV     ?V0 + 11,A
   \   00008E   78..         MOV     R0,#?V0 + 0
   \   000090   79..         MOV     R1,#?V0 + 8
   \   000092   12....       LCALL   ?L_ADD
   \   000095   7401         MOV     A,#0x1
   \   000097   12....       LCALL   ?XSTACK_DISP0_8
   \   00009A   78..         MOV     R0,#?V0 + 0
   \   00009C   12....       LCALL   ?L_MOV_TO_X
   1262          
   1263              zclSE_SimpleMetering_Send_ReqFastPollModeRsp( ESP_ENDPOINT, srcAddr,
   1264                                                            &fastPollRsp,
   1265                                                            TRUE, seqNum );
   \   00009F                ; Setup parameters for call to function zclSE_SimpleMetering_Send_ReqFastPollModeRsp
   \   00009F   EE           MOV     A,R6
   \   0000A0   F5..         MOV     ?V0 + 0,A
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   75..01       MOV     ?V0 + 0,#0x1
   \   0000AA   78..         MOV     R0,#?V0 + 0
   \   0000AC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AF   7402         MOV     A,#0x2
   \   0000B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B4   AC82         MOV     R4,DPL
   \   0000B6   AD83         MOV     R5,DPH
   \   0000B8   AA..         MOV     R2,?V0 + 12
   \   0000BA   AB..         MOV     R3,?V0 + 13
   \   0000BC   7909         MOV     R1,#0x9
   \   0000BE   12....       LCALL   ??zclSE_SimpleMetering_Send_ReqFastPollModeRsp?
   \   0000C1   7402         MOV     A,#0x2
   \   0000C3   12....       LCALL   ?DEALLOC_XSTACK8
   1266          
   1267          #if defined ( LCD_SUPPORTED )
   1268              HalLcdWriteString("Fast Polling", HAL_LCD_LINE_1);
   \   0000C6                ; Setup parameters for call to function HalLcdWriteString
   \   0000C6   7900         MOV     R1,#0x0
   \   0000C8   7A..         MOV     R2,#`?<Constant "Fast Polling">` & 0xff
   \   0000CA   7B..         MOV     R3,#(`?<Constant "Fast Polling">` >> 8) & 0xff
   \   0000CC   12....       LCALL   ??HalLcdWriteString?relay
   1269              HalLcdWriteStringValue("Cur 0x", utcSecs, 16, HAL_LCD_LINE_2 );
   \   0000CF                ; Setup parameters for call to function HalLcdWriteStringValue
   \   0000CF   78..         MOV     R0,#?V0 + 0
   \   0000D1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D4   7910         MOV     R1,#0x10
   \   0000D6   AC..         MOV     R4,?V0 + 4
   \   0000D8   AD..         MOV     R5,?V0 + 5
   \   0000DA   7A..         MOV     R2,#`?<Constant "Cur 0x">` & 0xff
   \   0000DC   7B..         MOV     R3,#(`?<Constant "Cur 0x">` >> 8) & 0xff
   \   0000DE   12....       LCALL   ??HalLcdWriteStringValue?relay
   \   0000E1   7401         MOV     A,#0x1
   \   0000E3   12....       LCALL   ?DEALLOC_XSTACK8
   1270              HalLcdWriteStringValue("End 0x", fastPollRsp.fastPollModeEndTime, 16, HAL_LCD_LINE_3 );
   \   0000E6                ; Setup parameters for call to function HalLcdWriteStringValue
   \   0000E6   75..02       MOV     ?V0 + 0,#0x2
   \   0000E9   78..         MOV     R0,#?V0 + 0
   \   0000EB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000EE   7910         MOV     R1,#0x10
   \   0000F0   7402         MOV     A,#0x2
   \   0000F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F5   78..         MOV     R0,#?V0 + 0
   \   0000F7   12....       LCALL   ?L_MOV_X
   \   0000FA   AC..         MOV     R4,?V0 + 0
   \   0000FC   AD..         MOV     R5,?V0 + 1
   \   0000FE   7A..         MOV     R2,#`?<Constant "End 0x">` & 0xff
   \   000100   7B..         MOV     R3,#(`?<Constant "End 0x">` >> 8) & 0xff
   \   000102   12....       LCALL   ??HalLcdWriteStringValue?relay
   \   000105   7401         MOV     A,#0x1
   \   000107   12....       LCALL   ?DEALLOC_XSTACK8
   1271          #endif
   1272            }
   1273          #endif // ZCL_SIMPLE_METERING
   1274          }
   \                     ??esp_ReqFastPollModeCmdCB_0:
   \   00010A   7405         MOV     A,#0x5
   \   00010C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00010F   7F0E         MOV     R7,#0xe
   \   000111   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#espFastPollModeDuration
   \   000004   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000007   E8           MOV     A,R0
   \   000008   22           RET
   1275          
   1276          /*********************************************************************
   1277           * @fn      esp_ReqFastPollModeRspCB
   1278           *
   1279           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1280           *          it received a Request Fast Poll Mode Response for
   1281           *          this application.
   1282           *
   1283           * @param   pRsp - pointer to structure for Request Fast Poll Mode Response command
   1284           * @param   srcAddr - pointer to source address
   1285           * @param   seqNum - sequence number of this command
   1286           *
   1287           * @return  none
   1288           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1289          static void esp_ReqFastPollModeRspCB( zclCCReqFastPollModeRsp_t *pRsp,
   \                     esp_ReqFastPollModeRspCB:
   1290                                                afAddrType_t *srcAddr, uint8 seqNum )
   1291          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1292            // add user code here
   1293          }
   \   000000   02....       LJMP    ?BRET
   1294          
   1295          /*********************************************************************
   1296           * @fn      esp_GetCurrentPriceCB
   1297           *
   1298           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1299           *          it received a Get Current Price for
   1300           *          this application.
   1301           *
   1302           * @param   pCmd - pointer to structure for Get Current Price command
   1303           * @param   srcAddr - pointer to source address
   1304           * @param   seqNum - sequence number for this command
   1305           *
   1306           * @return  none
   1307           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1308          static void esp_GetCurrentPriceCB( zclCCGetCurrentPrice_t *pCmd,
   \                     esp_GetCurrentPriceCB:
   1309                                                   afAddrType_t *srcAddr, uint8 seqNum )
   1310          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 44
   \   000005   74D4         MOV     A,#-0x2c
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V0 + 0,R1
   1311          #if defined ( ZCL_PRICING )
   1312            // On receipt of Get Current Price command, the device shall send a
   1313            // Publish Price command with the information for the current time.
   1314            zclCCPublishPrice_t cmd;
   1315            uint8 rateLabelLen = 4; // adjust this value if different label is set, test label "BASE"
   1316          
   1317            osal_memset( &cmd, 0, sizeof( zclCCPublishPrice_t ) );
   \   000010                ; Setup parameters for call to function osal_memset
   \   000010   7C2C         MOV     R4,#0x2c
   \   000012   7D00         MOV     R5,#0x0
   \   000014   7900         MOV     R1,#0x0
   \   000016   85..82       MOV     DPL,?XSP + 0
   \   000019   85..83       MOV     DPH,?XSP + 1
   \   00001C   AA82         MOV     R2,DPL
   \   00001E   AB83         MOV     R3,DPH
   \   000020   12....       LCALL   ??osal_memset?relay
   1318          
   1319            // Set Pricing information
   1320            cmd.providerId = 0xbabeface;
   \   000023   90....       MOV     DPTR,#__Constant_babeface
   \   000026   12....       LCALL   ?XLOAD_R2345
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   12....       LCALL   ?XSTORE_R2345
   1321            cmd.rateLabel.pStr = (uint8 *)osal_mem_alloc(rateLabelLen);
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   7A04         MOV     R2,#0x4
   \   000034   7B00         MOV     R3,#0x0
   \   000036   12....       LCALL   ??osal_mem_alloc?relay
   \   000039   7405         MOV     A,#0x5
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   EA           MOV     A,R2
   \   00003F   F0           MOVX    @DPTR,A
   \   000040   A3           INC     DPTR
   \   000041   EB           MOV     A,R3
   \   000042   F0           MOVX    @DPTR,A
   1322            if (cmd.rateLabel.pStr != NULL)
   \   000043   7405         MOV     A,#0x5
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00004B   602A         JZ      ??esp_GetCurrentPriceCB_0
   1323            {
   1324              cmd.rateLabel.strLen = rateLabelLen;
   \   00004D   7404         MOV     A,#0x4
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   7404         MOV     A,#0x4
   \   000054   F0           MOVX    @DPTR,A
   1325              osal_memcpy(cmd.rateLabel.pStr, "BASE", rateLabelLen);
   \   000055                ; Setup parameters for call to function osal_memcpy
   \   000055   75....       MOV     ?V0 + 4,#`?<Constant "BASE">` & 0xff
   \   000058   75....       MOV     ?V0 + 5,#(`?<Constant "BASE">` >> 8) & 0xff
   \   00005B   75..00       MOV     ?V0 + 6,#0x0
   \   00005E   78..         MOV     R0,#?V0 + 4
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000063   7C04         MOV     R4,#0x4
   \   000065   7D00         MOV     R5,#0x0
   \   000067   7408         MOV     A,#0x8
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   12....       LCALL   ?Subroutine15 & 0xFFFF
   1326            }
   \                     ??CrossCallReturnLabel_23:
   \   00006F   12....       LCALL   ??osal_memcpy?relay
   \   000072   7403         MOV     A,#0x3
   \   000074   12....       LCALL   ?DEALLOC_XSTACK8
   1327            cmd.issuerEventId = 0x00000000;
   \                     ??esp_GetCurrentPriceCB_0:
   \   000077   90....       MOV     DPTR,#__Constant_0
   \   00007A   12....       LCALL   ?XLOAD_R2345
   \   00007D   7407         MOV     A,#0x7
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   12....       LCALL   ?XSTORE_R2345
   1328            cmd.currentTime = osal_getClock();
   \   000085                ; Setup parameters for call to function osal_getClock
   \   000085   12....       LCALL   ??osal_getClock?relay
   \   000088   740B         MOV     A,#0xb
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   12....       LCALL   ?XSTORE_R2345
   1329            cmd.unitOfMeasure = 0x00;
   \   000090   740F         MOV     A,#0xf
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   E4           CLR     A
   \   000096   F0           MOVX    @DPTR,A
   1330            cmd.currency = 0x0348;
   \   000097   7410         MOV     A,#0x10
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   7448         MOV     A,#0x48
   \   00009E   F0           MOVX    @DPTR,A
   \   00009F   A3           INC     DPTR
   \   0000A0   7403         MOV     A,#0x3
   \   0000A2   F0           MOVX    @DPTR,A
   1331            cmd.priceTrailingDigit = 0x11;
   \   0000A3   7412         MOV     A,#0x12
   \   0000A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A8   7411         MOV     A,#0x11
   \   0000AA   F0           MOVX    @DPTR,A
   1332            cmd.numberOfPriceTiers = 0x21;
   \   0000AB   7413         MOV     A,#0x13
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   7421         MOV     A,#0x21
   \   0000B2   F0           MOVX    @DPTR,A
   1333            cmd.startTime = 0x00000000;
   \   0000B3   90....       MOV     DPTR,#__Constant_0
   \   0000B6   12....       LCALL   ?XLOAD_R2345
   \   0000B9   7414         MOV     A,#0x14
   \   0000BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BE   12....       LCALL   ?XSTORE_R2345
   1334            cmd.durationInMinutes = 0x003C;
   \   0000C1   7418         MOV     A,#0x18
   \   0000C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C6   743C         MOV     A,#0x3c
   \   0000C8   F0           MOVX    @DPTR,A
   \   0000C9   A3           INC     DPTR
   \   0000CA   E4           CLR     A
   \   0000CB   F0           MOVX    @DPTR,A
   1335            cmd.price = 0x00000018;
   \   0000CC   90....       MOV     DPTR,#__Constant_18
   \   0000CF   12....       LCALL   ?XLOAD_R2345
   \   0000D2   741A         MOV     A,#0x1a
   \   0000D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D7   12....       LCALL   ?XSTORE_R2345
   1336            cmd.priceRatio = SE_OPTIONAL_FIELD_UINT8;
   \   0000DA   741E         MOV     A,#0x1e
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   74FF         MOV     A,#-0x1
   \   0000E1   F0           MOVX    @DPTR,A
   1337            cmd.generationPrice = SE_OPTIONAL_FIELD_UINT32;
   \   0000E2   90....       MOV     DPTR,#__Constant_ffffffff
   \   0000E5   12....       LCALL   ?XLOAD_R2345
   \   0000E8   741F         MOV     A,#0x1f
   \   0000EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000ED   12....       LCALL   ?XSTORE_R2345
   1338            cmd.generationPriceRatio = SE_OPTIONAL_FIELD_UINT8;
   \   0000F0   7423         MOV     A,#0x23
   \   0000F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F5   74FF         MOV     A,#-0x1
   \   0000F7   F0           MOVX    @DPTR,A
   1339            cmd.alternateCostDelivered = SE_OPTIONAL_FIELD_UINT32;
   \   0000F8   90....       MOV     DPTR,#__Constant_ffffffff
   \   0000FB   12....       LCALL   ?XLOAD_R2345
   \   0000FE   7424         MOV     A,#0x24
   \   000100   12....       LCALL   ?XSTACK_DISP0_8
   \   000103   12....       LCALL   ?XSTORE_R2345
   1340            cmd.alternateCostUnit = SE_OPTIONAL_FIELD_UINT8;
   \   000106   7428         MOV     A,#0x28
   \   000108   12....       LCALL   ?XSTACK_DISP0_8
   \   00010B   74FF         MOV     A,#-0x1
   \   00010D   F0           MOVX    @DPTR,A
   1341            cmd.alternateCostTrailingDigit = SE_OPTIONAL_FIELD_UINT8;
   \   00010E   7429         MOV     A,#0x29
   \   000110   12....       LCALL   ?XSTACK_DISP0_8
   \   000113   74FF         MOV     A,#-0x1
   \   000115   F0           MOVX    @DPTR,A
   1342            cmd.numberOfBlockThresholds = SE_OPTIONAL_FIELD_UINT8;
   \   000116   742A         MOV     A,#0x2a
   \   000118   12....       LCALL   ?XSTACK_DISP0_8
   \   00011B   74FF         MOV     A,#-0x1
   \   00011D   F0           MOVX    @DPTR,A
   1343            cmd.priceControl = SE_PROFILE_PRICEACK_REQUIRED_MASK;
   \   00011E   742B         MOV     A,#0x2b
   \   000120   12....       LCALL   ?XSTACK_DISP0_8
   \   000123   7401         MOV     A,#0x1
   \   000125   F0           MOVX    @DPTR,A
   1344          
   1345            // copy source address of display device that requested current pricing info so
   1346            // that esp can send messages to it using destination address of IPDAddr
   1347            osal_memcpy( &ipdAddr, srcAddr, sizeof ( afAddrType_t ) );
   \   000126                ; Setup parameters for call to function osal_memcpy
   \   000126   8E..         MOV     ?V0 + 4,R6
   \   000128   8F..         MOV     ?V0 + 5,R7
   \   00012A   75..00       MOV     ?V0 + 6,#0x0
   \   00012D   78..         MOV     R0,#?V0 + 4
   \   00012F   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000132   7C0C         MOV     R4,#0xc
   \   000134   7D00         MOV     R5,#0x0
   \   000136   7A..         MOV     R2,#ipdAddr & 0xff
   \   000138   7B..         MOV     R3,#(ipdAddr >> 8) & 0xff
   \   00013A   12....       LCALL   ??osal_memcpy?relay
   \   00013D   7403         MOV     A,#0x3
   \   00013F   12....       LCALL   ?DEALLOC_XSTACK8
   1348          
   1349            zclSE_Pricing_Send_PublishPrice( ESP_ENDPOINT, srcAddr, &cmd, FALSE, seqNum );
   \   000142                ; Setup parameters for call to function zclSE_Pricing_Send_PublishPrice
   \   000142   E5..         MOV     A,?V0 + 0
   \   000144   F5..         MOV     ?V0 + 1,A
   \   000146   78..         MOV     R0,#?V0 + 1
   \   000148   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00014B   75..00       MOV     ?V0 + 1,#0x0
   \   00014E   78..         MOV     R0,#?V0 + 1
   \   000150   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000153   7402         MOV     A,#0x2
   \   000155   12....       LCALL   ?XSTACK_DISP0_8
   \   000158   AC82         MOV     R4,DPL
   \   00015A   AD83         MOV     R5,DPH
   \   00015C   EE           MOV     A,R6
   \   00015D   FA           MOV     R2,A
   \   00015E   EF           MOV     A,R7
   \   00015F   FB           MOV     R3,A
   \   000160   7909         MOV     R1,#0x9
   \   000162   12....       LCALL   ??zclSE_Pricing_Send_PublishPrice?relay
   \   000165   7402         MOV     A,#0x2
   \   000167   12....       LCALL   ?DEALLOC_XSTACK8
   1350          
   1351            if (cmd.rateLabel.pStr != NULL)
   \   00016A   7405         MOV     A,#0x5
   \   00016C   12....       LCALL   ?XSTACK_DISP0_8
   \   00016F   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000172   6008         JZ      ??CrossCallReturnLabel_16
   1352            {
   1353              osal_mem_free(cmd.rateLabel.pStr);
   \   000174                ; Setup parameters for call to function osal_mem_free
   \   000174   7405         MOV     A,#0x5
   \   000176   12....       LCALL   ?XSTACK_DISP0_8
   \   000179   12....       LCALL   ?Subroutine11 & 0xFFFF
   1354            }
   1355          #endif // ZCL_PRICING
   1356          }
   \                     ??CrossCallReturnLabel_16:
   \   00017C   742C         MOV     A,#0x2c
   \   00017E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000181   7F07         MOV     R7,#0x7
   \   000183   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   12....       LCALL   ??osal_mem_free?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
   1357          
   1358          /*********************************************************************
   1359           * @fn      esp_GetScheduledPriceCB
   1360           *
   1361           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1362           *          it received a Get Scheduled Price for
   1363           *          this application.
   1364           *
   1365           * @param   pCmd - pointer to structure for Get Scheduled Price command
   1366           * @param   srcAddr - pointer to source address
   1367           * @param   seqNum - sequence number for this command
   1368           *
   1369           * @return  none
   1370           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1371          static void esp_GetScheduledPriceCB( zclCCGetScheduledPrice_t *pCmd,
   \                     esp_GetScheduledPriceCB:
   1372                                               afAddrType_t *srcAddr, uint8 seqNum  )
   1373          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 44
   \   000005   74D4         MOV     A,#-0x2c
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V0 + 0,R1
   1374            // On receipt of Get Scheduled Price command, the device shall send a
   1375            // Publish Price command for all currently scheduled price events.
   1376            // The sample code as follows only sends one.
   1377          
   1378          #if defined ( ZCL_PRICING )
   1379            zclCCPublishPrice_t cmd;
   1380          
   1381            osal_memset( &cmd, 0, sizeof( zclCCPublishPrice_t ) );
   \   000010                ; Setup parameters for call to function osal_memset
   \   000010   7C2C         MOV     R4,#0x2c
   \   000012   7D00         MOV     R5,#0x0
   \   000014   7900         MOV     R1,#0x0
   \   000016   85..82       MOV     DPL,?XSP + 0
   \   000019   85..83       MOV     DPH,?XSP + 1
   \   00001C   AA82         MOV     R2,DPL
   \   00001E   AB83         MOV     R3,DPH
   \   000020   12....       LCALL   ??osal_memset?relay
   1382          
   1383            cmd.providerId = 0xbabeface;
   \   000023   90....       MOV     DPTR,#__Constant_babeface
   \   000026   12....       LCALL   ?XLOAD_R2345
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   12....       LCALL   ?XSTORE_R2345
   1384            cmd.numberOfPriceTiers = 0xfe;
   \   000032   7413         MOV     A,#0x13
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   74FE         MOV     A,#-0x2
   \   000039   F0           MOVX    @DPTR,A
   1385          
   1386            zclSE_Pricing_Send_PublishPrice( ESP_ENDPOINT, srcAddr, &cmd, FALSE, seqNum );
   \   00003A                ; Setup parameters for call to function zclSE_Pricing_Send_PublishPrice
   \   00003A   E5..         MOV     A,?V0 + 0
   \   00003C   F5..         MOV     ?V0 + 1,A
   \   00003E   78..         MOV     R0,#?V0 + 1
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000043   75..00       MOV     ?V0 + 1,#0x0
   \   000046   78..         MOV     R0,#?V0 + 1
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004B   7402         MOV     A,#0x2
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   AC82         MOV     R4,DPL
   \   000052   AD83         MOV     R5,DPH
   \   000054   EE           MOV     A,R6
   \   000055   FA           MOV     R2,A
   \   000056   EF           MOV     A,R7
   \   000057   FB           MOV     R3,A
   \   000058   7909         MOV     R1,#0x9
   \   00005A   12....       LCALL   ??zclSE_Pricing_Send_PublishPrice?relay
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   1387          
   1388          #endif // ZCL_PRICING
   1389          }
   \   000062   742C         MOV     A,#0x2c
   \   000064   02....       LJMP    ??Subroutine27_0 & 0xFFFF
   1390          
   1391          /*********************************************************************
   1392           * @fn      esp_PriceAcknowledgementCB
   1393           *
   1394           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1395           *          it received a Price Acknowledgement for this application.
   1396           *
   1397           * @param   pCmd - pointer to structure for Price Acknowledgement command
   1398           * @param   srcAddr - pointer to source address
   1399           * @param   seqNum - sequence number for this command
   1400           *
   1401           * @return  none
   1402           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1403          static void esp_PriceAcknowledgementCB( zclCCPriceAcknowledgement_t *pCmd,
   \                     esp_PriceAcknowledgementCB:
   1404                                                  afAddrType_t *srcAddr, uint8 seqNum )
   1405          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1406            // add user code here
   1407          }
   \   000000   02....       LJMP    ?BRET
   1408          
   1409          /*********************************************************************
   1410           * @fn      esp_GetBlockPeriodCB
   1411           *
   1412           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1413           *          it received a Get Block Period for this application.
   1414           *
   1415           * @param   pCmd - pointer to structure for Get Block Period command
   1416           * @param   srcAddr - pointer to source address
   1417           * @param   seqNum - sequence number for this command
   1418           *
   1419           * @return  none
   1420           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1421          static void esp_GetBlockPeriodCB( zclCCGetBlockPeriod_t *pCmd,
   \                     esp_GetBlockPeriodCB:
   1422                                            afAddrType_t *srcAddr, uint8 seqNum )
   1423          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1424            // add user code here
   1425          }
   \   000000   02....       LJMP    ?BRET
   1426          
   1427          /*********************************************************************
   1428           * @fn      esp_PublishPriceCB
   1429           *
   1430           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1431           *          it received a Publish Price for this application.
   1432           *
   1433           * @param   pCmd - pointer to structure for Publish Price command
   1434           * @param   srcAddr - pointer to source address
   1435           * @param   seqNum - sequence number for this command
   1436           *
   1437           * @return  none
   1438           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1439          static void esp_PublishPriceCB( zclCCPublishPrice_t *pCmd,
   \                     esp_PublishPriceCB:
   1440                                                afAddrType_t *srcAddr, uint8 seqNum )
   1441          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1442            // add user code here
   1443          }
   \   000000   02....       LJMP    ?BRET
   1444          
   1445          /*********************************************************************
   1446           * @fn      esp_PublishBlockPeriodCB
   1447           *
   1448           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1449           *          it received a Publish Block Period for this application.
   1450           *
   1451           * @param   pCmd - pointer to structure for Get Block Period command
   1452           * @param   srcAddr - pointer to source address
   1453           * @param   seqNum - sequence number for this command
   1454           *
   1455           * @return  none
   1456           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1457          static void esp_PublishBlockPeriodCB( zclCCPublishBlockPeriod_t *pCmd,
   \                     esp_PublishBlockPeriodCB:
   1458                                                afAddrType_t *srcAddr, uint8 seqNum )
   1459          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1460            // add user code here
   1461          }
   \   000000   02....       LJMP    ?BRET
   1462          
   1463          /*********************************************************************
   1464           * @fn      esp_DisplayMessageCB
   1465           *
   1466           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1467           *          it received a Display Message Command for
   1468           *          this application.
   1469           *
   1470           * @param   pCmd - pointer to structure for Display Message command
   1471           * @param   srcAddr - pointer to source address
   1472           * @param   seqNum - sequence number for this command
   1473           *
   1474           * @return  none
   1475           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1476          static void esp_DisplayMessageCB( zclCCDisplayMessage_t *pCmd,
   \                     esp_DisplayMessageCB:
   1477                                                  afAddrType_t *srcAddr, uint8 seqNum )
   1478          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1479            // Upon receipt of the Display Message Command, the device shall
   1480            // display the message. If the Message Confirmation bit indicates
   1481            // the message originator require a confirmation of receipt from
   1482            // a Utility Customer, the device should display the message or
   1483            // alert the user until it is either confirmed via a button or by
   1484            // selecting a confirmation option on the device.  Confirmation is
   1485            // typically used when the Utility is sending down information
   1486            // such as a disconnection notice, or prepaid billing information.
   1487            // Message duration is ignored when confirmation is requested and
   1488            // the message is displayed until confirmed.
   1489          
   1490          #if defined ( LCD_SUPPORTED )
   1491              HalLcdWriteString( (char*)pCmd->msgString.pStr, HAL_LCD_LINE_1 );
   \   000004                ; Setup parameters for call to function HalLcdWriteString
   \   000004   7900         MOV     R1,#0x0
   \   000006   EA           MOV     A,R2
   \   000007   2410         ADD     A,#0x10
   \   000009   F582         MOV     DPL,A
   \   00000B   EB           MOV     A,R3
   \   00000C   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   00000F   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000012   12....       LCALL   ??HalLcdWriteString?relay
   1492          #endif // LCD_SUPPORTED
   1493          }
   \   000015   02....       LJMP    ?Subroutine2 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine33_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET
   1494          
   1495          /*********************************************************************
   1496           * @fn      esp_CancelMessageCB
   1497           *
   1498           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1499           *          it received a Cancel Message Command for
   1500           *          this application.
   1501           *
   1502           * @param   pCmd - pointer to structure for Cancel Message command
   1503           * @param   srcAddr - pointer to source address
   1504           * @param   seqNum - sequence number for this command
   1505           *
   1506           * @return  none
   1507           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1508          static void esp_CancelMessageCB( zclCCCancelMessage_t *pCmd,
   \                     esp_CancelMessageCB:
   1509                                                  afAddrType_t *srcAddr, uint8 seqNum )
   1510          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1511            // add user code here
   1512          }
   \   000000   02....       LJMP    ?BRET
   1513          
   1514          /*********************************************************************
   1515           * @fn      esp_GetLastMessageCB
   1516           *
   1517           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1518           *          it received a Get Last Message Command for
   1519           *          this application.
   1520           *
   1521           * @param   pCmd - pointer to structure for Get Last Message command
   1522           * @param   srcAddr - pointer to source address
   1523           * @param   seqNum - sequence number for this command
   1524           *
   1525           * @return  none
   1526           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1527          static void esp_GetLastMessageCB( afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_GetLastMessageCB:
   1528          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 28
   \   000005   74E4         MOV     A,#-0x1c
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V0 + 0,R1
   1529            // On receipt of Get Last Message command, the device shall send a
   1530            // Display Message command back to the sender
   1531          
   1532          #if defined ( ZCL_MESSAGE )
   1533            zclCCDisplayMessage_t cmd;
   1534            uint8 msg[10] = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29 };
   \   000010   7412         MOV     A,#0x12
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   AC82         MOV     R4,DPL
   \   000017   AD83         MOV     R5,DPH
   \   000019   7583..       MOV     DPH,#(`?<Constant {32, 33, 34, 35, 36, 37, 38, 39, 40` >> 8) & 0xff
   \   00001C   7582..       MOV     DPL,#`?<Constant {32, 33, 34, 35, 36, 37, 38, 39, 40` & 0xff
   \   00001F   740A         MOV     A,#0xa
   \   000021   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   1535          
   1536            // Fill in the command with information for the last message
   1537            cmd.messageId = 0xaabbccdd;
   \   000024   90....       MOV     DPTR,#__Constant_aabbccdd
   \   000027   12....       LCALL   ?XLOAD_R2345
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   12....       LCALL   ?XSTORE_R2345
   1538            cmd.messageCtrl.transmissionMode = 0;
   \   000033   7404         MOV     A,#0x4
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E4           CLR     A
   \   000039   F0           MOVX    @DPTR,A
   1539            cmd.messageCtrl.importance = 1;
   \   00003A   7405         MOV     A,#0x5
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   7401         MOV     A,#0x1
   \   000041   F0           MOVX    @DPTR,A
   1540            cmd.messageCtrl.confirmationRequired = 1;
   \   000042   7408         MOV     A,#0x8
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   7401         MOV     A,#0x1
   \   000049   F0           MOVX    @DPTR,A
   1541            cmd.durationInMinutes = 60;
   \   00004A   740D         MOV     A,#0xd
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   743C         MOV     A,#0x3c
   \   000051   F0           MOVX    @DPTR,A
   \   000052   A3           INC     DPTR
   \   000053   E4           CLR     A
   \   000054   F0           MOVX    @DPTR,A
   1542          
   1543            cmd.msgString.strLen = 10;
   \   000055   740F         MOV     A,#0xf
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   740A         MOV     A,#0xa
   \   00005C   F0           MOVX    @DPTR,A
   1544            cmd.msgString.pStr = msg;
   \   00005D   7412         MOV     A,#0x12
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   A882         MOV     R0,DPL
   \   000064   A983         MOV     R1,DPH
   \   000066   7410         MOV     A,#0x10
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   12....       LCALL   ?Subroutine7 & 0xFFFF
   1545          
   1546            zclSE_Message_Send_DisplayMessage( ESP_ENDPOINT, srcAddr, &cmd,
   1547                                               FALSE, seqNum );
   \                     ??CrossCallReturnLabel_8:
   \   00006E                ; Setup parameters for call to function zclSE_Message_Send_DisplayMessage
   \   00006E   E5..         MOV     A,?V0 + 0
   \   000070   F5..         MOV     ?V0 + 1,A
   \   000072   78..         MOV     R0,#?V0 + 1
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000077   75..00       MOV     ?V0 + 1,#0x0
   \   00007A   78..         MOV     R0,#?V0 + 1
   \   00007C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007F   7402         MOV     A,#0x2
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   AC82         MOV     R4,DPL
   \   000086   AD83         MOV     R5,DPH
   \   000088   EE           MOV     A,R6
   \   000089   FA           MOV     R2,A
   \   00008A   EF           MOV     A,R7
   \   00008B   FB           MOV     R3,A
   \   00008C   7909         MOV     R1,#0x9
   \   00008E   12....       LCALL   ??zclSE_Message_Send_DisplayMessage?relay
   \   000091   7402         MOV     A,#0x2
   \   000093   12....       LCALL   ?DEALLOC_XSTACK8
   1548          #endif // ZCL_MESSAGe
   1549          }
   \   000096   741C         MOV     A,#0x1c
   \   000098   02....       LJMP    ??Subroutine27_0 & 0xFFFF
   1550          
   1551          /*********************************************************************
   1552           * @fn      esp_MessageConfirmationCB
   1553           *
   1554           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1555           *          it received a Message Confirmation Command for
   1556           *          this application.
   1557           *
   1558           * @param   pCmd - pointer to structure for Message Confirmation command
   1559           * @param   srcAddr - pointer to source address
   1560           * @param   seqNum - sequence number for this command
   1561           *
   1562           * @return  none
   1563           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1564          static void esp_MessageConfirmationCB( zclCCMessageConfirmation_t *pCmd,
   \                     esp_MessageConfirmationCB:
   1565                                                       afAddrType_t *srcAddr, uint8 seqNum)
   1566          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1567            // add user code here
   1568          }
   \   000000   02....       LJMP    ?BRET
   1569          
   1570          #if defined (ZCL_LOAD_CONTROL)
   1571          /*********************************************************************
   1572           * @fn      esp_SendReportEventStatus
   1573           *
   1574           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1575           *          it received a Load Control Event Command for
   1576           *          this application.
   1577           *
   1578           * @param   afAddrType_t *srcAddr - pointer to source address
   1579           * @param   uint8 seqNum - sequence number for this event
   1580           * @param   uint32 eventID - event ID for this event
   1581           * @param   uint32 startTime - start time for this event
   1582           * @param   uint8 eventStatus - status for this event
   1583           * @param   uint8 criticalityLevel - criticality level for this event
   1584           * @param   uint8 eventControl - event control for this event
   1585           *
   1586           * @return  none
   1587           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1588          static void esp_SendReportEventStatus( afAddrType_t *srcAddr, uint8 seqNum,
   \                     esp_SendReportEventStatus:
   1589                                                        uint32 eventID, uint32 startTime,
   1590                                                        uint8 eventStatus, uint8 criticalityLevel,
   1591                                                        uint8 eventControl )
   1592          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 14,R2
   \   000007   8B..         MOV     ?V0 + 15,R3
   \   000009   89..         MOV     ?V0 + 13,R1
   \   00000B   8C..         MOV     ?V0 + 5,R4
   \   00000D   8D..         MOV     ?V0 + 4,R5
   \   00000F   7418         MOV     A,#0x18
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   78..         MOV     R0,#?V0 + 8
   \   000016   12....       LCALL   ?L_MOV_X
   \   000019   741C         MOV     A,#0x1c
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   78..         MOV     R0,#?V0 + 0
   \   000020   12....       LCALL   ?L_MOV_X
   \   000023   7420         MOV     A,#0x20
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V0 + 12,A
   1593            zclCCReportEventStatus_t *pRsp;
   1594          
   1595            pRsp = (zclCCReportEventStatus_t *)osal_mem_alloc( sizeof( zclCCReportEventStatus_t ) );
   \   00002B                ; Setup parameters for call to function osal_mem_alloc
   \   00002B   7A3C         MOV     R2,#0x3c
   \   00002D   7B00         MOV     R3,#0x0
   \   00002F   12....       LCALL   ??osal_mem_alloc?relay
   \   000032   8A..         MOV     ?V0 + 6,R2
   \   000034   8B..         MOV     ?V0 + 7,R3
   \   000036   AE..         MOV     R6,?V0 + 6
   \   000038   AF..         MOV     R7,?V0 + 7
   1596          
   1597            if ( pRsp != NULL)
   \   00003A   EE           MOV     A,R6
   \   00003B   4F           ORL     A,R7
   \   00003C   7003         JNZ     $+5
   \   00003E   02....       LJMP    ??esp_SendReportEventStatus_0 & 0xFFFF
   1598            {
   1599              // Mandatory fields - use the incoming data
   1600              pRsp->issuerEventID = eventID;
   \   000041   8E82         MOV     DPL,R6
   \   000043   8F83         MOV     DPH,R7
   \   000045   78..         MOV     R0,#?V0 + 8
   \   000047   12....       LCALL   ?L_MOV_TO_X
   1601              pRsp->eventStartTime = startTime;
   \   00004A   8E82         MOV     DPL,R6
   \   00004C   8F83         MOV     DPH,R7
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   12....       LCALL   ?L_MOV_TO_X
   1602              pRsp->criticalityLevelApplied = criticalityLevel;
   \   000057   8E82         MOV     DPL,R6
   \   000059   8F83         MOV     DPH,R7
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   E5..         MOV     A,?V0 + 4
   \   000066   F0           MOVX    @DPTR,A
   1603              pRsp->eventControl = eventControl;
   \   000067   EE           MOV     A,R6
   \   000068   2410         ADD     A,#0x10
   \   00006A   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   00006D   E5..         MOV     A,?V0 + 12
   \   00006F   12....       LCALL   ?Subroutine5 & 0xFFFF
   1604              pRsp->eventStatus = eventStatus;
   \                     ??CrossCallReturnLabel_2:
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   E5..         MOV     A,?V0 + 5
   \   000076   F0           MOVX    @DPTR,A
   1605              pRsp->signatureType = SE_PROFILE_SIGNATURE_TYPE_ECDSA;
   \   000077   EE           MOV     A,R6
   \   000078   2411         ADD     A,#0x11
   \   00007A   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   00007D   7401         MOV     A,#0x1
   \   00007F   F0           MOVX    @DPTR,A
   1606          
   1607              // esp_Signature is a static array.
   1608              // value can be changed in esp_data.c
   1609              osal_memcpy( pRsp->signature, espSignature, 16 );
   \   000080                ; Setup parameters for call to function osal_memcpy
   \   000080   75....       MOV     ?V0 + 0,#espSignature & 0xff
   \   000083   75....       MOV     ?V0 + 1,#(espSignature >> 8) & 0xff
   \   000086   75..00       MOV     ?V0 + 2,#0x0
   \   000089   78..         MOV     R0,#?V0 + 0
   \   00008B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00008E   7C10         MOV     R4,#0x10
   \   000090   7D00         MOV     R5,#0x0
   \   000092   EE           MOV     A,R6
   \   000093   2412         ADD     A,#0x12
   \   000095   FA           MOV     R2,A
   \   000096   EF           MOV     A,R7
   \   000097   3400         ADDC    A,#0x0
   \   000099   FB           MOV     R3,A
   \   00009A   12....       LCALL   ??osal_memcpy?relay
   \   00009D   7403         MOV     A,#0x3
   \   00009F   12....       LCALL   ?DEALLOC_XSTACK8
   1610          
   1611              // Optional fields - fill in with non-used value by default
   1612              pRsp->coolingTemperatureSetPointApplied = SE_OPTIONAL_FIELD_TEMPERATURE_SET_POINT;
   \   0000A2   8E82         MOV     DPL,R6
   \   0000A4   8F83         MOV     DPH,R7
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   E4           CLR     A
   \   0000B1   F0           MOVX    @DPTR,A
   \   0000B2   A3           INC     DPTR
   \   0000B3   7480         MOV     A,#-0x80
   \   0000B5   F0           MOVX    @DPTR,A
   1613              pRsp->heatingTemperatureSetPointApplied = SE_OPTIONAL_FIELD_TEMPERATURE_SET_POINT;
   \   0000B6   EE           MOV     A,R6
   \   0000B7   240C         ADD     A,#0xc
   \   0000B9   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   0000BC   E4           CLR     A
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   A3           INC     DPTR
   \   0000BF   7480         MOV     A,#-0x80
   \   0000C1   F0           MOVX    @DPTR,A
   1614              pRsp->averageLoadAdjustment = SE_OPTIONAL_FIELD_INT8;
   \   0000C2   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   0000C5   7480         MOV     A,#-0x80
   \   0000C7   F0           MOVX    @DPTR,A
   1615              pRsp->dutyCycleApplied = SE_OPTIONAL_FIELD_UINT8;
   \   0000C8   EE           MOV     A,R6
   \   0000C9   240F         ADD     A,#0xf
   \   0000CB   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   0000CE   74FF         MOV     A,#-0x1
   \   0000D0   F0           MOVX    @DPTR,A
   1616          
   1617              // Send response back
   1618              // DisableDefaultResponse is set to FALSE - it is recommended to turn on
   1619              // default response since Report Event Status Command does not have
   1620              // a response.
   1621              zclSE_LoadControl_Send_ReportEventStatus( ESP_ENDPOINT, srcAddr,
   1622                                                      pRsp, FALSE, seqNum );
   \   0000D1                ; Setup parameters for call to function zclSE_LoadControl_Send_ReportEventStatus
   \   0000D1   E5..         MOV     A,?V0 + 13
   \   0000D3   F5..         MOV     ?V0 + 0,A
   \   0000D5   78..         MOV     R0,#?V0 + 0
   \   0000D7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000DA   75..00       MOV     ?V0 + 0,#0x0
   \   0000DD   78..         MOV     R0,#?V0 + 0
   \   0000DF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000E2   EE           MOV     A,R6
   \   0000E3   FC           MOV     R4,A
   \   0000E4   EF           MOV     A,R7
   \   0000E5   FD           MOV     R5,A
   \   0000E6   AA..         MOV     R2,?V0 + 14
   \   0000E8   AB..         MOV     R3,?V0 + 15
   \   0000EA   7909         MOV     R1,#0x9
   \   0000EC   12....       LCALL   ??zclSE_LoadControl_Send_ReportEventStatus?rela
   \   0000EF   7402         MOV     A,#0x2
   \   0000F1   12....       LCALL   ?DEALLOC_XSTACK8
   1623              osal_mem_free( pRsp );
   \   0000F4                ; Setup parameters for call to function osal_mem_free
   \   0000F4   EE           MOV     A,R6
   \   0000F5   FA           MOV     R2,A
   \   0000F6   EF           MOV     A,R7
   \   0000F7   FB           MOV     R3,A
   \   0000F8   12....       LCALL   ??osal_mem_free?relay
   1624            }
   1625          }
   \                     ??esp_SendReportEventStatus_0:
   \   0000FB   7F10         MOV     R7,#0x10
   \   0000FD   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function zcl_SendConfigReportRspCmd
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   EE           MOV     A,R6
   \   000001   240E         ADD     A,#0xe
   \   000003                REQUIRE ??Subroutine32_0
   \   000003                ; // Fall through to label ??Subroutine32_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine32_0:
   \   000000   F582         MOV     DPL,A
   \   000002   EF           MOV     A,R7
   \   000003                REQUIRE ??Subroutine33_0
   \   000003                ; // Fall through to label ??Subroutine33_0
   1626          #endif // ZCL_LOAD_CONTROL
   1627          
   1628          /*********************************************************************
   1629           * @fn      esp_LoadControlEventCB
   1630           *
   1631           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1632           *          it received a Load Control Event Command for
   1633           *          this application.
   1634           *
   1635           * @param   pCmd - pointer to load control event command
   1636           * @param   srcAddr - pointer to source address
   1637           * @param   status - event status
   1638           * @param   seqNum - sequence number of this command
   1639           *
   1640           * @return  none
   1641           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ??esp_SendReportEventStatus?relay
   \   000003   7409         MOV     A,#0x9
   \   000005                REQUIRE ??Subroutine27_0
   \   000005                ; // Fall through to label ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1642          static void esp_LoadControlEventCB( zclCCLoadControlEvent_t *pCmd,
   \                     esp_LoadControlEventCB:
   1643                                                         afAddrType_t *srcAddr, uint8 status,
   1644                                                         uint8 seqNum)
   1645          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EC           MOV     A,R4
   \   00000A   FA           MOV     R2,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FB           MOV     R3,A
   \   00000D   89..         MOV     ?V0 + 0,R1
   \   00000F   740A         MOV     A,#0xa
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   1646          #if defined ( ZCL_LOAD_CONTROL )
   1647            // According to the Smart Metering Specification, upon receipt
   1648            // of the Load Control Event command, the receiving device shall
   1649            // send Report Event Status command back.
   1650            uint8 eventStatus;
   1651          
   1652            if ( status == ZCL_STATUS_INVALID_FIELD )
   \   000016   7485         MOV     A,#-0x7b
   \   000018   65..         XRL     A,?V0 + 0
   \   00001A   7004         JNZ     ??esp_LoadControlEventCB_0
   1653            {
   1654              // If the incoming message has invalid fields in it
   1655              // Send response back with status: rejected
   1656              eventStatus = EVENT_STATUS_LOAD_CONTROL_EVENT_REJECTED;
   \   00001C   7CFE         MOV     R4,#-0x2
   \   00001E   8002         SJMP    ??esp_LoadControlEventCB_1
   1657            }
   1658            else
   1659            { // Send response back with status: received
   1660              eventStatus = EVENT_STATUS_LOAD_CONTROL_EVENT_RECEIVED;
   \                     ??esp_LoadControlEventCB_0:
   \   000020   7C01         MOV     R4,#0x1
   1661            }
   1662          
   1663            // Send response back
   1664            esp_SendReportEventStatus( srcAddr, seqNum, pCmd->issuerEvent,
   1665                                             pCmd->startTime, eventStatus,
   1666                                             pCmd->criticalityLevel, pCmd->eventControl);
   \                     ??esp_LoadControlEventCB_1:
   \   000022                ; Setup parameters for call to function esp_SendReportEventStatus
   \   000022   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000025   F5..         MOV     ?V0 + 1,A
   \   000027   78..         MOV     R0,#?V0 + 1
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00002C   8E82         MOV     DPL,R6
   \   00002E   8F83         MOV     DPH,R7
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   000042   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000045   E0           MOVX    A,@DPTR
   \   000046   FD           MOV     R5,A
   \   000047   02....       LJMP    ?Subroutine0 & 0xFFFF
   1667          
   1668            if ( status != ZCL_STATUS_INVALID_FIELD )
   1669            {
   1670              // add user load control event handler here
   1671            }
   1672          #endif // ZCL_LOAD_CONTROL
   1673          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   EE           MOV     A,R6
   \   000001   2417         ADD     A,#0x17
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET
   1674          
   1675          /*********************************************************************
   1676           * @fn      esp_CancelLoadControlEventCB
   1677           *
   1678           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1679           *          it received a Cancel Load Control Event Command for
   1680           *          this application.
   1681           *
   1682           * @param   pCmd - pointer to structure for Cancel Load Control Event command
   1683           * @param   scrAddr - source address
   1684           * @param   seqNum - sequence number for this command
   1685           *
   1686           * @return  none
   1687           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1688          static void esp_CancelLoadControlEventCB( zclCCCancelLoadControlEvent_t *pCmd,
   \                     esp_CancelLoadControlEventCB:
   1689                                                          afAddrType_t *srcAddr, uint8 seqNum )
   1690          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EC           MOV     A,R4
   \   00000A   FA           MOV     R2,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FB           MOV     R3,A
   1691          #if defined ( ZCL_LOAD_CONTROL )
   1692            if ( 0 )  // User shall replace the if condition with "if the event exist"
   1693            {
   1694              // If the event exist, stop the event, and respond with status: cancelled
   1695          
   1696              // Cancel the event here
   1697          
   1698              // Use the following sample code to send response back.
   1699              /*
   1700              esp_SendReportEventStatus( srcAddr, seqNum, pCmd->issuerEventID,
   1701                                               // startTime
   1702                                               EVENT_STATUS_LOAD_CONTROL_EVENT_CANCELLED, // eventStatus
   1703                                               // Criticality level
   1704                                               // eventControl };
   1705              */
   1706          
   1707            }
   1708            else
   1709            {
   1710              // If the event does not exist, respond with status: rejected
   1711              // The rest of the mandatory fields are not available, therefore,
   1712              // set to optional value
   1713              esp_SendReportEventStatus( srcAddr, seqNum, pCmd->issuerEventID,
   1714                                               SE_OPTIONAL_FIELD_UINT32,                  // startTime
   1715                                               EVENT_STATUS_LOAD_CONTROL_EVENT_RECEIVED,  // eventStatus
   1716                                               SE_OPTIONAL_FIELD_UINT8,                   // Criticality level
   1717                                               SE_OPTIONAL_FIELD_UINT8 );                 // eventControl
   \   00000D                ; Setup parameters for call to function esp_SendReportEventStatus
   \   00000D   75..FF       MOV     ?V0 + 1,#-0x1
   \   000010   78..         MOV     R0,#?V0 + 1
   \   000012   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000015   90....       MOV     DPTR,#__Constant_ffffffff
   \   000018   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   00001B   8E82         MOV     DPL,R6
   \   00001D   8F83         MOV     DPH,R7
   \   00001F   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   000022   7DFF         MOV     R5,#-0x1
   \   000024   7C01         MOV     R4,#0x1
   \   000026   02....       LJMP    ?Subroutine0 & 0xFFFF
   1718            }
   1719          
   1720          #endif // ZCL_LOAD_CONTROL
   1721          }
   1722          
   1723          /*********************************************************************
   1724           * @fn      esp_CancelAllLoadControlEventsCB
   1725           *
   1726           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1727           *          it received a Cancel All Load Control Event Command for
   1728           *          this application.
   1729           *
   1730           * @param   pCmd - pointer to structure for Cancel All Load Control Event command
   1731           * @param   scrAddr - source address
   1732           * @param   seqNum - sequence number for this command
   1733           *
   1734           * @return  none
   1735           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1736          static void esp_CancelAllLoadControlEventsCB( zclCCCancelAllLoadControlEvents_t *pCmd,
   \                     esp_CancelAllLoadControlEventsCB:
   1737                                                              afAddrType_t *srcAddr, uint8 seqNum )
   1738          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1739            // Upon receipt of Cancel All Load Control Event Command,
   1740            // the receiving device shall look up the table for all events
   1741            // and send a seperate response for each event
   1742          
   1743          }
   \   000000   02....       LJMP    ?BRET
   1744          
   1745          /*********************************************************************
   1746           * @fn      esp_ReportEventStatusCB
   1747           *
   1748           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1749           *          it received a Report Event Status Command for
   1750           *          this application.
   1751           *
   1752           * @param   pCmd - pointer to structure for Report Event Status command
   1753           * @param   scrAddr - source address
   1754           * @param   seqNum - sequence number for this command
   1755           *
   1756           * @return  none
   1757           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1758          static void esp_ReportEventStatusCB( zclCCReportEventStatus_t *pCmd,
   \                     esp_ReportEventStatusCB:
   1759                                                     afAddrType_t *srcAddr, uint8 seqNum)
   1760          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1761            // add user code here
   1762          }
   \   000000   02....       LJMP    ?BRET
   1763          /*********************************************************************
   1764           * @fn      esp_GetScheduledEventCB
   1765           *
   1766           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1767           *          it received a Get Scheduled Event Command for
   1768           *          this application.
   1769           *
   1770           * @param   pCmd - pointer to structure for Get Scheduled Event command
   1771           * @param   scrAddr - source address
   1772           * @param   seqNum - sequence number for this command
   1773           *
   1774           * @return  none
   1775           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1776          static void esp_GetScheduledEventCB( zclCCGetScheduledEvent_t *pCmd,
   \                     esp_GetScheduledEventCB:
   1777                                                     afAddrType_t *srcAddr, uint8 seqNum )
   1778          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1779            // add user code here
   1780          }
   \   000000   02....       LJMP    ?BRET
   1781          
   1782          /*********************************************************************
   1783           * @fn      esp_SelAvailEmergencyCreditCmdCB
   1784           *
   1785           * @brief   Callback from the ZCL SE Prepayment Cluster Library when it recieved
   1786           *          Select Available Emergency Credit command in the application
   1787           *
   1788           * @param   pCmd - pointer to structure for Select Available Emergency Credit command
   1789           * @param   srcAddr - pointer to source address
   1790           * @param   seqNum - Sequence no of the message
   1791           *
   1792           * @return  none
   1793           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1794          static void esp_SelAvailEmergencyCreditCmdCB( zclCCSelAvailEmergencyCredit_t *pCmd,
   \                     esp_SelAvailEmergencyCreditCmdCB:
   1795                                                        afAddrType_t *srcAddr, uint8 seqNum )
   1796          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1797          #if defined ( ZCL_PREPAYMENT )
   1798          #if defined ( LCD_SUPPORTED )
   1799            HalLcdWriteString("Emergency Credit", HAL_LCD_LINE_1);
   1800          
   1801            if ((pCmd->siteId.strLen > 0) &&
   1802                (pCmd->siteId.strLen <= HAL_LCD_MAX_CHARS) &&
   1803                (pCmd->siteId.pStr != NULL))
   1804            {
   1805              HalLcdWriteString((char*)pCmd->siteId.pStr, HAL_LCD_LINE_2);
   1806            }
   1807          
   1808            if ((pCmd->meterSerialNumber.strLen > 0) &&
   1809                (pCmd->meterSerialNumber.strLen <= HAL_LCD_MAX_CHARS) &&
   1810                (pCmd->meterSerialNumber.pStr != NULL))
   1811            {
   1812              HalLcdWriteString((char*)pCmd->meterSerialNumber.pStr, HAL_LCD_LINE_3);
   1813            }
   1814          #endif
   1815          #endif  // ZCL_PREPAYMENT
   1816          }
   \   000000   02....       LJMP    ?BRET
   1817          
   1818          /*********************************************************************
   1819           * @fn      esp_ChangeSupplyCmdCB
   1820           *
   1821           * @brief   Callback from the ZCL SE Prepayment Cluster Library when it recieved
   1822           *          Change Supply command in the application
   1823           *
   1824           * @param   pCmd - pointer to structure for Change Supply command
   1825           * @param   srcAddr - pointer to source address
   1826           * @param   seqNum - Sequence no of the message
   1827           *
   1828           * @return  none
   1829           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1830          static void esp_ChangeSupplyCmdCB( zclCCChangeSupply_t *pCmd,
   \                     esp_ChangeSupplyCmdCB:
   1831                                                 afAddrType_t *srcAddr, uint8 seqNum )
   1832          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1833          #if defined ( ZCL_PREPAYMENT )
   1834          #if !defined ( SE_UK_EXT )
   1835            zclCCSupplyStatusResponse_t SupplyStatus_cmd;
   1836          
   1837            osal_memset( &SupplyStatus_cmd, 0, sizeof( zclCCSupplyStatusResponse_t ) );
   1838          
   1839            SupplyStatus_cmd.providerId = pCmd->providerId;
   1840            SupplyStatus_cmd.implementationDateTime = osal_getClock();
   1841            SupplyStatus_cmd.supplyStatus = pCmd->proposedSupplyStatus;
   1842          
   1843            zclSE_Prepayment_Send_SupplyStatusResponse( ESP_ENDPOINT, srcAddr, &SupplyStatus_cmd,
   1844                                                        FALSE, seqNum );
   1845          #endif  // SE_UK_EXT
   1846          #endif  // ZCL_PREPAYMENT
   1847          }
   \   000000   02....       LJMP    ?BRET
   1848          
   1849          /*********************************************************************
   1850           * @fn      esp_SupplyStatusRspCB
   1851           *
   1852           * @brief    Callback from the ZCL SE Prepayment Cluster Library when it recieved
   1853           *           Supply Status Response command in the application
   1854           *
   1855           * @param   pCmd - pointer to structure for Supply Status Response command
   1856           * @param   srcAddr - pointer to source address
   1857           * @param   seqNum - Sequence no of the message
   1858           *
   1859           * @return  none
   1860           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1861          static void esp_SupplyStatusRspCB( zclCCSupplyStatusResponse_t *pCmd,
   \                     esp_SupplyStatusRspCB:
   1862                                                 afAddrType_t *srcAddr, uint8 seqNum )
   1863          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1864            // add user code here
   1865          }
   \   000000   02....       LJMP    ?BRET
   1866          
   1867          #if defined ( SE_UK_EXT )
   1868          /*********************************************************************
   1869           * @fn      esp_GetSnapshotRspCB
   1870           *
   1871           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1872           *          it received a Get Snapshot Response for
   1873           *          this application.
   1874           *
   1875           * @param   pCmd - pointer to structure for Get Snapshot Response command
   1876           * @param   srcAddr - pointer to source address
   1877           * @param   seqNum - sequence number of this command
   1878           *
   1879           * @return  none
   1880           */
   1881          static void esp_GetSnapshotRspCB( zclCCReqGetSnapshotRsp_t *pCmd,
   1882                                            afAddrType_t *srcAddr, uint8 seqNum )
   1883          {
   1884            // add user code here
   1885          }
   1886          
   1887          /*********************************************************************
   1888           * @fn      esp_PublishTariffInformationCB
   1889           *
   1890           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1891           *          it received a Publish Tariff Information for this application.
   1892           *
   1893           * @param   pCmd - pointer to structure for Publish Tariff Information command
   1894           * @param   srcAddr - pointer to source address
   1895           * @param   seqNum - sequence number of this command
   1896           *
   1897           * @return  none
   1898           */
   1899          static void esp_PublishTariffInformationCB( zclCCPublishTariffInformation_t *pCmd,
   1900                                                      afAddrType_t *srcAddr, uint8 seqNum )
   1901          {
   1902            // add user code here
   1903          }
   1904          
   1905          /*********************************************************************
   1906           * @fn      esp_PublishPriceMatrixCB
   1907           *
   1908           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1909           *          it received a Publish Price Matrix for this application.
   1910           *
   1911           * @param   pCmd - pointer to structure for Publish Price Matrix command
   1912           * @param   srcAddr - pointer to source address
   1913           * @param   seqNum - sequence number of this command
   1914           *
   1915           * @return  none
   1916           */
   1917          static void esp_PublishPriceMatrixCB( zclCCPublishPriceMatrix_t *pCmd,
   1918                                                afAddrType_t *srcAddr, uint8 seqNum )
   1919          {
   1920            // add user code here
   1921          }
   1922          
   1923          /*********************************************************************
   1924           * @fn      esp_PublishBlockThresholdsCB
   1925           *
   1926           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1927           *          it received a Publish Block Thresholds for this application.
   1928           *
   1929           * @param   pCmd - pointer to structure for Publish Block Thresholds command
   1930           * @param   srcAddr - pointer to source address
   1931           * @param   seqNum - sequence number of this command
   1932           *
   1933           * @return  none
   1934           */
   1935          static void esp_PublishBlockThresholdsCB( zclCCPublishBlockThresholds_t *pCmd,
   1936                                                    afAddrType_t *srcAddr, uint8 seqNum )
   1937          {
   1938            // add user code here
   1939          }
   1940          
   1941          /*********************************************************************
   1942           * @fn      esp_PublishConversionFactorCB
   1943           *
   1944           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1945           *          it received a Publish Conversion Factor for this application.
   1946           *
   1947           * @param   pCmd - pointer to structure for Publish Conversion Factor command
   1948           * @param   srcAddr - pointer to source address
   1949           * @param   seqNum - sequence number of this command
   1950           *
   1951           * @return  none
   1952           */
   1953          static void esp_PublishConversionFactorCB( zclCCPublishConversionFactor_t *pCmd,
   1954                                                     afAddrType_t *srcAddr, uint8 seqNum )
   1955          {
   1956            // add user code here
   1957          }
   1958          
   1959          /*********************************************************************
   1960           * @fn      esp_PublishCalorificValueCB
   1961           *
   1962           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1963           *          it received a Publish Calorific Value for this application.
   1964           *
   1965           * @param   pCmd - pointer to structure for Publish Calorific Value command
   1966           * @param   srcAddr - pointer to source address
   1967           * @param   seqNum - sequence number of this command
   1968           *
   1969           * @return  none
   1970           */
   1971          static void esp_PublishCalorificValueCB( zclCCPublishCalorificValue_t *pCmd,
   1972                                                   afAddrType_t *srcAddr, uint8 seqNum )
   1973          {
   1974            // add user code here
   1975          }
   1976          
   1977          /*********************************************************************
   1978           * @fn      esp_PublishCO2ValueCB
   1979           *
   1980           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1981           *          it received a Publish CO2 Value for this application.
   1982           *
   1983           * @param   pCmd - pointer to structure for Publish CO2 Value command
   1984           * @param   srcAddr - pointer to source address
   1985           * @param   seqNum - sequence number of this command
   1986           *
   1987           * @return  none
   1988           */
   1989          static void esp_PublishCO2ValueCB( zclCCPublishCO2Value_t *pCmd,
   1990                                             afAddrType_t *srcAddr, uint8 seqNum )
   1991          {
   1992            // add user code here
   1993          }
   1994          
   1995          /*********************************************************************
   1996           * @fn      esp_PublishCPPEventCB
   1997           *
   1998           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1999           *          it received a Publish CPP Event for this application.
   2000           *
   2001           * @param   pCmd - pointer to structure for Publish CPP Event command
   2002           * @param   srcAddr - pointer to source address
   2003           * @param   seqNum - sequence number of this command
   2004           *
   2005           * @return  none
   2006           */
   2007          static void esp_PublishCPPEventCB( zclCCPublishCPPEvent_t *pCmd,
   2008                                             afAddrType_t *srcAddr, uint8 seqNum )
   2009          {
   2010            // add user code here
   2011          }
   2012          
   2013          /*********************************************************************
   2014           * @fn      esp_PublishBillingPeriodCB
   2015           *
   2016           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2017           *          it received a Publish Billing Period for this application.
   2018           *
   2019           * @param   pCmd - pointer to structure for Publish Billing Period command
   2020           * @param   srcAddr - pointer to source address
   2021           * @param   seqNum - sequence number of this command
   2022           *
   2023           * @return  none
   2024           */
   2025          static void esp_PublishBillingPeriodCB( zclCCPublishBillingPeriod_t *pCmd,
   2026                                                  afAddrType_t *srcAddr, uint8 seqNum )
   2027          {
   2028            // add user code here
   2029          }
   2030          
   2031          /*********************************************************************
   2032           * @fn      esp_PublishConsolidatedBillCB
   2033           *
   2034           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2035           *          it received a Publish Consolidated Bill for this application.
   2036           *
   2037           * @param   pCmd - pointer to structure for Publish Consolidated Bill command
   2038           * @param   srcAddr - pointer to source address
   2039           * @param   seqNum - sequence number of this command
   2040           *
   2041           * @return  none
   2042           */
   2043          static void esp_PublishConsolidatedBillCB( zclCCPublishConsolidatedBill_t *pCmd,
   2044                                                     afAddrType_t *srcAddr, uint8 seqNum )
   2045          {
   2046            // add user code here
   2047          }
   2048          
   2049          /*********************************************************************
   2050           * @fn      esp_PublishCreditPaymentInfoCB
   2051           *
   2052           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2053           *          it received a Publish Credit Payment Info for this application.
   2054           *
   2055           * @param   pCmd - pointer to structure for Publish Credit Payment Info command
   2056           * @param   srcAddr - pointer to source address
   2057           * @param   seqNum - sequence number of this command
   2058           *
   2059           * @return  none
   2060           */
   2061          static void esp_PublishCreditPaymentInfoCB( zclCCPublishCreditPaymentInfo_t *pCmd,
   2062                                                      afAddrType_t *srcAddr, uint8 seqNum )
   2063          {
   2064            // add user code here
   2065          }
   2066          
   2067          /*********************************************************************
   2068           * @fn      esp_GetTariffInformationCB
   2069           *
   2070           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2071           *          it received a Get Tariff Information for this application.
   2072           *
   2073           * @param   pCmd - pointer to structure for Get Tariff Information command
   2074           * @param   srcAddr - pointer to source address
   2075           * @param   seqNum - sequence number of this command
   2076           *
   2077           * @return  none
   2078           */
   2079          static void esp_GetTariffInformationCB( zclCCGetTariffInformation_t *pCmd,
   2080                                                  afAddrType_t *srcAddr, uint8 seqNum )
   2081          {
   2082            // add user code here
   2083          }
   2084          
   2085          /*********************************************************************
   2086           * @fn      esp_GetPriceMatrixCB
   2087           *
   2088           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2089           *          it received a Get Price Matrix for this application.
   2090           *
   2091           * @param   issuerTariffId - issuer tariff Id
   2092           * @param   srcAddr - pointer to source address
   2093           * @param   seqNum - sequence number of this command
   2094           *
   2095           * @return  none
   2096           */
   2097          static void esp_GetPriceMatrixCB( uint32 issuerTariffId,
   2098                                            afAddrType_t *srcAddr, uint8 seqNum )
   2099          {
   2100            // add user code here
   2101          }
   2102          
   2103          /*********************************************************************
   2104           * @fn      esp_GetBlockThresholdsCB
   2105           *
   2106           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2107           *          it received a Get Block Thresholds for this application.
   2108           *
   2109           * @param   issuerTariffId - issuer tariff Id
   2110           * @param   srcAddr - pointer to source address
   2111           * @param   seqNum - sequence number of this command
   2112           *
   2113           * @return  none
   2114           */
   2115          static void esp_GetBlockThresholdsCB( uint32 issuerTariffId,
   2116                                                afAddrType_t *srcAddr, uint8 seqNum )
   2117          {
   2118            // add user code here
   2119          }
   2120          
   2121          /*********************************************************************
   2122           * @fn      esp_GetConversionFactorCB
   2123           *
   2124           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2125           *          it received a Get Conversion Factor for this application.
   2126           *
   2127           * @param   pCmd - pointer to structure for Get Conversion Factor command
   2128           * @param   srcAddr - pointer to source address
   2129           * @param   seqNum - sequence number of this command
   2130           *
   2131           * @return  none
   2132           */
   2133          static void esp_GetConversionFactorCB( zclCCGetConversionFactor_t *pCmd,
   2134                                                 afAddrType_t *srcAddr, uint8 seqNum )
   2135          {
   2136            // add user code here
   2137          }
   2138          
   2139          /*********************************************************************
   2140           * @fn      esp_GetCalorificValueCB
   2141           *
   2142           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2143           *          it received a Get Calorific Value for this application.
   2144           *
   2145           * @param   pCmd - pointer to structure for Get Calorific Value command
   2146           * @param   srcAddr - pointer to source address
   2147           * @param   seqNum - sequence number of this command
   2148           *
   2149           * @return  none
   2150           */
   2151          static void esp_GetCalorificValueCB( zclCCGetCalorificValue_t *pCmd,
   2152                                               afAddrType_t *srcAddr, uint8 seqNum )
   2153          {
   2154            // add user code here
   2155          }
   2156          
   2157          /*********************************************************************
   2158           * @fn      esp_GetCO2ValueCB
   2159           *
   2160           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2161           *          it received a Get CO2 Value for this application.
   2162           *
   2163           * @param   pCmd - pointer to structure for Get CO2 Value command
   2164           * @param   srcAddr - pointer to source address
   2165           * @param   seqNum - sequence number of this command
   2166           *
   2167           * @return  none
   2168           */
   2169          static void esp_GetCO2ValueCB( zclCCGetCO2Value_t *pCmd,
   2170                                         afAddrType_t *srcAddr, uint8 seqNum )
   2171          {
   2172            // add user code here
   2173          }
   2174          
   2175          /*********************************************************************
   2176           * @fn      esp_GetBillingPeriodCB
   2177           *
   2178           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2179           *          it received a Get Billing Period for this application.
   2180           *
   2181           * @param   pCmd - pointer to structure for Get Billing Period command
   2182           * @param   srcAddr - pointer to source address
   2183           * @param   seqNum - sequence number of this command
   2184           *
   2185           * @return  none
   2186           */
   2187          static void esp_GetBillingPeriodCB( zclCCGetBillingPeriod_t *pCmd,
   2188                                              afAddrType_t *srcAddr, uint8 seqNum )
   2189          {
   2190            // add user code here
   2191          }
   2192          
   2193          /*********************************************************************
   2194           * @fn      esp_GetConsolidatedBillCB
   2195           *
   2196           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2197           *          it received a Get Consolidated Bill for this application.
   2198           *
   2199           * @param   pCmd - pointer to structure for Get Consolidated Bill command
   2200           * @param   srcAddr - pointer to source address
   2201           * @param   seqNum - sequence number of this command
   2202           *
   2203           * @return  none
   2204           */
   2205          static void esp_GetConsolidatedBillCB( zclCCGetConsolidatedBill_t *pCmd,
   2206                                                 afAddrType_t *srcAddr, uint8 seqNum )
   2207          {
   2208            // add user code here
   2209          }
   2210          
   2211          /*********************************************************************
   2212           * @fn      esp_CPPEventResponseCB
   2213           *
   2214           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2215           *          it received a CPP Event Response for this application.
   2216           *
   2217           * @param   pCmd - pointer to structure for CPP Event Response command
   2218           * @param   srcAddr - pointer to source address
   2219           * @param   seqNum - sequence number of this command
   2220           *
   2221           * @return  none
   2222           */
   2223          static void esp_CPPEventResponseCB( zclCCCPPEventResponse_t *pCmd,
   2224                                              afAddrType_t *srcAddr, uint8 seqNum )
   2225          {
   2226            // add user code here
   2227          }
   2228          
   2229          /*********************************************************************
   2230           * @fn      esp_ChangeDebtCB
   2231           *
   2232           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2233           *          it received a Change Debt for this application.
   2234           *
   2235           * @param   pCmd - pointer to structure for Change Debt command
   2236           * @param   srcAddr - pointer to source address
   2237           * @param   seqNum - sequence number of this command
   2238           *
   2239           * @return  none
   2240           */
   2241          static void esp_ChangeDebtCB( zclCCChangeDebt_t *pCmd,
   2242                                        afAddrType_t *srcAddr, uint8 seqNum )
   2243          {
   2244            // add user code here
   2245          }
   2246          
   2247          /*********************************************************************
   2248           * @fn      esp_EmergencyCreditSetupCB
   2249           *
   2250           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2251           *          it received a Emergency Credit Setup for this application.
   2252           *
   2253           * @param   pCmd - pointer to structure for Emergency Credit Setup command
   2254           * @param   srcAddr - pointer to source address
   2255           * @param   seqNum - sequence number of this command
   2256           *
   2257           * @return  none
   2258           */
   2259          static void esp_EmergencyCreditSetupCB( zclCCEmergencyCreditSetup_t *pCmd,
   2260                                                  afAddrType_t *srcAddr, uint8 seqNum )
   2261          {
   2262            // add user code here
   2263          }
   2264          
   2265          /*********************************************************************
   2266           * @fn      esp_ConsumerTopupCB
   2267           *
   2268           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2269           *          it received a Consumer Topup for this application.
   2270           *
   2271           * @param   pCmd - pointer to structure for Consumer Topup command
   2272           * @param   srcAddr - pointer to source address
   2273           * @param   seqNum - sequence number of this command
   2274           *
   2275           * @return  none
   2276           */
   2277          static void esp_ConsumerTopupCB( zclCCConsumerTopup_t *pCmd,
   2278                                           afAddrType_t *srcAddr, uint8 seqNum )
   2279          {
   2280            // add user code here
   2281          }
   2282          
   2283          /*********************************************************************
   2284           * @fn      esp_CreditAdjustmentCB
   2285           *
   2286           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2287           *          it received a Credit Adjustment for this application.
   2288           *
   2289           * @param   pCmd - pointer to structure for Credit Adjustment command
   2290           * @param   srcAddr - pointer to source address
   2291           * @param   seqNum - sequence number of this command
   2292           *
   2293           * @return  none
   2294           */
   2295          static void esp_CreditAdjustmentCB( zclCCCreditAdjustment_t *pCmd,
   2296                                              afAddrType_t *srcAddr, uint8 seqNum )
   2297          {
   2298            // add user code here
   2299          }
   2300          
   2301          /*********************************************************************
   2302           * @fn      esp_ChangePaymentModeCB
   2303           *
   2304           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2305           *          it received a Change Payment Mode for this application.
   2306           *
   2307           * @param   pCmd - pointer to structure for Change Payment Mode command
   2308           * @param   srcAddr - pointer to source address
   2309           * @param   seqNum - sequence number of this command
   2310           *
   2311           * @return  none
   2312           */
   2313          static void esp_ChangePaymentModeCB( zclCCChangePaymentMode_t *pCmd,
   2314                                               afAddrType_t *srcAddr, uint8 seqNum )
   2315          {
   2316            // add user code here
   2317          }
   2318          
   2319          /*********************************************************************
   2320           * @fn      esp_GetPrepaySnapshotCB
   2321           *
   2322           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2323           *          it received a Get Prepay Snapshot for this application.
   2324           *
   2325           * @param   pCmd - pointer to structure for Get Prepay Snapshot command
   2326           * @param   srcAddr - pointer to source address
   2327           * @param   seqNum - sequence number of this command
   2328           *
   2329           * @return  none
   2330           */
   2331          static void esp_GetPrepaySnapshotCB( zclCCGetPrepaySnapshot_t *pCmd,
   2332                                               afAddrType_t *srcAddr, uint8 seqNum )
   2333          {
   2334            // add user code here
   2335          }
   2336          
   2337          /*********************************************************************
   2338           * @fn      esp_GetTopupLogCB
   2339           *
   2340           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2341           *          it received a Get Topup Log for this application.
   2342           *
   2343           * @param   numEvents - number of events
   2344           * @param   srcAddr - pointer to source address
   2345           * @param   seqNum - sequence number of this command
   2346           *
   2347           * @return  none
   2348           */
   2349          static void esp_GetTopupLogCB( uint8 numEvents,
   2350                                         afAddrType_t *srcAddr, uint8 seqNum )
   2351          {
   2352            // add user code here
   2353          }
   2354          
   2355          /*********************************************************************
   2356           * @fn      esp_SetLowCreditWarningLevelCB
   2357           *
   2358           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2359           *          it received a Set Low Credit Warning Level for this application.
   2360           *
   2361           * @param   numEvents - number of events
   2362           * @param   srcAddr - pointer to source address
   2363           * @param   seqNum - sequence number of this command
   2364           *
   2365           * @return  none
   2366           */
   2367          static void esp_SetLowCreditWarningLevelCB( uint8 numEvents,
   2368                                                      afAddrType_t *srcAddr, uint8 seqNum )
   2369          {
   2370            // add user code here
   2371          }
   2372          
   2373          /*********************************************************************
   2374           * @fn      esp_GetDebtRepaymentLogCB
   2375           *
   2376           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2377           *          it received a Get Debt Repayment Log for this application.
   2378           *
   2379           * @param   pCmd - pointer to structure for Get Debt Repayment Log command
   2380           * @param   srcAddr - pointer to source address
   2381           * @param   seqNum - sequence number of this command
   2382           *
   2383           * @return  none
   2384           */
   2385          static void esp_GetDebtRepaymentLogCB( zclCCGetDebtRepaymentLog_t *pCmd,
   2386                                                 afAddrType_t *srcAddr, uint8 seqNum )
   2387          {
   2388            // add user code here
   2389          }
   2390          
   2391          /*********************************************************************
   2392           * @fn      esp_GetPrepaySnapshotResponseCB
   2393           *
   2394           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2395           *          it received a Get Prepay Snapshot Response for this application.
   2396           *
   2397           * @param   pCmd - pointer to structure for Get Prepay Snapshot Response command
   2398           * @param   srcAddr - pointer to source address
   2399           * @param   seqNum - sequence number of this command
   2400           *
   2401           * @return  none
   2402           */
   2403          static void esp_GetPrepaySnapshotResponseCB( zclCCGetPrepaySnapshotResponse_t *pCmd,
   2404                                                       afAddrType_t *srcAddr, uint8 seqNum )
   2405          {
   2406            // add user code here
   2407          }
   2408          
   2409          /*********************************************************************
   2410           * @fn      esp_ChangePaymentModeResponseCB
   2411           *
   2412           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2413           *          it received a Change Payment Mode Response for this application.
   2414           *
   2415           * @param   pCmd - pointer to structure for Change Payment Mode Response command
   2416           * @param   srcAddr - pointer to source address
   2417           * @param   seqNum - sequence number of this command
   2418           *
   2419           * @return  none
   2420           */
   2421          static void esp_ChangePaymentModeResponseCB( zclCCChangePaymentModeResponse_t *pCmd,
   2422                                                       afAddrType_t *srcAddr, uint8 seqNum )
   2423          {
   2424            // add user code here
   2425          }
   2426          
   2427          /*********************************************************************
   2428           * @fn      esp_ConsumerTopupResponseCB
   2429           *
   2430           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2431           *          it received a Consumer Topup Response for this application.
   2432           *
   2433           * @param   pCmd - pointer to structure for Consumer Topup Response command
   2434           * @param   srcAddr - pointer to source address
   2435           * @param   seqNum - sequence number of this command
   2436           *
   2437           * @return  none
   2438           */
   2439          static void esp_ConsumerTopupResponseCB( zclCCConsumerTopupResponse_t *pCmd,
   2440                                                   afAddrType_t *srcAddr, uint8 seqNum )
   2441          {
   2442            // add user code here
   2443          }
   2444          
   2445          /*********************************************************************
   2446           * @fn      esp_GetCommandsCB
   2447           *
   2448           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2449           *          it received a Get Commands for this application.
   2450           *
   2451           * @param   prepayNotificationFlags - prepayment notification flags
   2452           * @param   srcAddr - pointer to source address
   2453           * @param   seqNum - sequence number of this command
   2454           *
   2455           * @return  none
   2456           */
   2457          static void esp_GetCommandsCB( uint8 prepayNotificationFlags,
   2458                                         afAddrType_t *srcAddr, uint8 seqNum )
   2459          {
   2460            // add user code here
   2461          }
   2462          
   2463          /*********************************************************************
   2464           * @fn      esp_PublishTopupLogCB
   2465           *
   2466           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2467           *          it received a Publish Topup Log for this application.
   2468           *
   2469           * @param   pCmd - pointer to structure for Publish Topup Log command
   2470           * @param   srcAddr - pointer to source address
   2471           * @param   seqNum - sequence number of this command
   2472           *
   2473           * @return  none
   2474           */
   2475          static void esp_PublishTopupLogCB( zclCCPublishTopupLog_t *pCmd,
   2476                                             afAddrType_t *srcAddr, uint8 seqNum )
   2477          {
   2478            // add user code here
   2479          }
   2480          
   2481          /*********************************************************************
   2482           * @fn      esp_PublishDebtLogCB
   2483           *
   2484           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2485           *          it received a Publish Debt Log for this application.
   2486           *
   2487           * @param   pCmd - pointer to structure for Publish Debt Log command
   2488           * @param   srcAddr - pointer to source address
   2489           * @param   seqNum - sequence number of this command
   2490           *
   2491           * @return  none
   2492           */
   2493          static void esp_PublishDebtLogCB( zclCCPublishDebtLog_t *pCmd,
   2494                                            afAddrType_t *srcAddr, uint8 seqNum )
   2495          {
   2496            // add user code here
   2497          }
   2498          #endif // SE_UK_EXT
   2499          
   2500          /******************************************************************************
   2501           *
   2502           *  Functions for processing ZDO incoming messages
   2503           *
   2504           *****************************************************************************/
   2505          
   2506          /*********************************************************************
   2507           * @fn      esp_ProcessZDOMsg
   2508           *
   2509           * @brief   Process the incoming ZDO messages.
   2510           *
   2511           * @param   inMsg - message to process
   2512           *
   2513           * @return  none
   2514           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004                REQUIRE ??Subroutine30_0
   \   000004                ; // Fall through to label ??Subroutine30_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2515          static void esp_ProcessZDOMsg( zdoIncomingMsg_t *inMsg )
   \                     esp_ProcessZDOMsg:
   2516          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2517            ZDO_DeviceAnnce_t devAnnce;
   2518          
   2519            switch ( inMsg->clusterID )
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000014   78..         MOV     R0,#?V0 + 0
   \   000016   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for esp_ProcessZDOMsg>_0`:
   \   000019   0000         DW        0
   \   00001B   0200         DW        2
   \   00001D   1300         DW        19
   \   00001F   ....         DW        ??esp_ProcessZDOMsg_0
   \   000021   0480         DW        32772
   \   000023   ....         DW        ??esp_ProcessZDOMsg_1
   \   000025   ....         DW        ??esp_ProcessZDOMsg_2
   2520            {
   2521              case Device_annce:
   2522                {
   2523                  ZDO_ParseDeviceAnnce( inMsg, &devAnnce );
   \                     ??esp_ProcessZDOMsg_0:
   \   000027                ; Setup parameters for call to function ZDO_ParseDeviceAnnce
   \   000027   85..82       MOV     DPL,?XSP + 0
   \   00002A   85..83       MOV     DPH,?XSP + 1
   \   00002D   AC82         MOV     R4,DPL
   \   00002F   AD83         MOV     R5,DPH
   \   000031   12....       LCALL   ??ZDO_ParseDeviceAnnce?relay
   2524                  simpleDescReqAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   000034   90....       MOV     DPTR,#simpleDescReqAddr + 8
   \   000037   7402         MOV     A,#0x2
   \   000039   F0           MOVX    @DPTR,A
   2525                  simpleDescReqAddr.addr.shortAddr = devAnnce.nwkAddr;
   \   00003A   85..82       MOV     DPL,?XSP + 0
   \   00003D   85..83       MOV     DPH,?XSP + 1
   \   000040   12....       LCALL   ??Subroutine29_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000043   90....       MOV     DPTR,#simpleDescReqAddr
   \   000046   12....       LCALL   ?Subroutine7 & 0xFFFF
   2526          
   2527                  // set simple descriptor query event
   2528                  osal_set_event( espTaskID, SIMPLE_DESC_QUERY_EVT );
   \                     ??CrossCallReturnLabel_9:
   \   000049                ; Setup parameters for call to function osal_set_event
   \   000049   7A04         MOV     R2,#0x4
   \   00004B   7B00         MOV     R3,#0x0
   \   00004D   90....       MOV     DPTR,#espTaskID
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F9           MOV     R1,A
   \   000052   12....       LCALL   ??osal_set_event?relay
   2529                }
   2530                break;
   \   000055   02....       LJMP    ??esp_ProcessZDOMsg_2 & 0xFFFF
   2531          
   2532              case Simple_Desc_rsp:
   2533                {
   2534                  ZDO_SimpleDescRsp_t *pSimpleDescRsp;   // pointer to received simple desc response
   2535                  pSimpleDescRsp = (ZDO_SimpleDescRsp_t *)osal_mem_alloc( sizeof( ZDO_SimpleDescRsp_t ) );
   \                     ??esp_ProcessZDOMsg_1:
   \   000058                ; Setup parameters for call to function osal_mem_alloc
   \   000058   7A0F         MOV     R2,#0xf
   \   00005A   7B00         MOV     R3,#0x0
   \   00005C   12....       LCALL   ??osal_mem_alloc?relay
   \   00005F   8A..         MOV     ?V0 + 0,R2
   \   000061   8B..         MOV     ?V0 + 1,R3
   2536          
   2537                  if(pSimpleDescRsp)
   \   000063   EA           MOV     A,R2
   \   000064   45..         ORL     A,?V0 + 1
   \   000066   7003         JNZ     $+5
   \   000068   02....       LJMP    ??esp_ProcessZDOMsg_2 & 0xFFFF
   2538                  {
   2539                    pSimpleDescRsp->simpleDesc.pAppInClusterList = NULL;
   \   00006B   8A82         MOV     DPL,R2
   \   00006D   8B83         MOV     DPH,R3
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   E4           CLR     A
   \   00007A   F0           MOVX    @DPTR,A
   \   00007B   A3           INC     DPTR
   \   00007C   F0           MOVX    @DPTR,A
   2540                    pSimpleDescRsp->simpleDesc.pAppOutClusterList = NULL;
   \   00007D   EA           MOV     A,R2
   \   00007E   240D         ADD     A,#0xd
   \   000080   F582         MOV     DPL,A
   \   000082   EB           MOV     A,R3
   \   000083   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000086   E4           CLR     A
   \   000087   F0           MOVX    @DPTR,A
   \   000088   A3           INC     DPTR
   \   000089   F0           MOVX    @DPTR,A
   2541          
   2542                    ZDO_ParseSimpleDescRsp( inMsg, pSimpleDescRsp );
   \   00008A                ; Setup parameters for call to function ZDO_ParseSimpleDescRsp
   \   00008A   AC..         MOV     R4,?V0 + 0
   \   00008C   AD..         MOV     R5,?V0 + 1
   \   00008E   EE           MOV     A,R6
   \   00008F   FA           MOV     R2,A
   \   000090   EF           MOV     A,R7
   \   000091   FB           MOV     R3,A
   \   000092   12....       LCALL   ??ZDO_ParseSimpleDescRsp?relay
   2543                    if( pSimpleDescRsp->simpleDesc.AppDeviceId == ZCL_SE_DEVICEID_PCT ) // this is a PCT
   \   000095   85..82       MOV     DPL,?V0 + 0
   \   000098   85..83       MOV     DPH,?V0 + 1
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   6403         XRL     A,#0x3
   \   0000A4   7004         JNZ     ??esp_ProcessZDOMsg_3
   \   0000A6   A3           INC     DPTR
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   6405         XRL     A,#0x5
   \                     ??esp_ProcessZDOMsg_3:
   \   0000AA   85..82       MOV     DPL,?V0 + 0
   \   0000AD   85..83       MOV     DPH,?V0 + 1
   \   0000B0   A3           INC     DPTR
   \   0000B1   7008         JNZ     ??esp_ProcessZDOMsg_4
   2544                    {
   2545                      pctAddr.addr.shortAddr = pSimpleDescRsp->nwkAddr;
   \   0000B3   12....       LCALL   ??Subroutine29_0 & 0xFFFF
   2546                    }
   \                     ??CrossCallReturnLabel_43:
   \   0000B6   90....       MOV     DPTR,#pctAddr
   \   0000B9   801C         SJMP    ??esp_ProcessZDOMsg_5
   2547                    else if ( pSimpleDescRsp->simpleDesc.AppDeviceId == ZCL_SE_DEVICEID_LOAD_CTRL_EXTENSION ) // this is a load control device
   \                     ??esp_ProcessZDOMsg_4:
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   A3           INC     DPTR
   \   0000BF   A3           INC     DPTR
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   6404         XRL     A,#0x4
   \   0000C3   7004         JNZ     ??esp_ProcessZDOMsg_6
   \   0000C5   A3           INC     DPTR
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   6405         XRL     A,#0x5
   \                     ??esp_ProcessZDOMsg_6:
   \   0000C9   700F         JNZ     ??CrossCallReturnLabel_10
   2548                    {
   2549                      loadControlAddr.addr.shortAddr = pSimpleDescRsp->nwkAddr;
   \   0000CB   85..82       MOV     DPL,?V0 + 0
   \   0000CE   85..83       MOV     DPH,?V0 + 1
   \   0000D1   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   2550                    }
   \                     ??CrossCallReturnLabel_44:
   \   0000D4   90....       MOV     DPTR,#loadControlAddr
   \                     ??esp_ProcessZDOMsg_5:
   \   0000D7   12....       LCALL   ?Subroutine7 & 0xFFFF
   2551          
   2552                    // free memory for InClusterList
   2553                    if (pSimpleDescRsp->simpleDesc.pAppInClusterList)
   \                     ??CrossCallReturnLabel_10:
   \   0000DA   85..82       MOV     DPL,?V0 + 0
   \   0000DD   85..83       MOV     DPH,?V0 + 1
   \   0000E0   A3           INC     DPTR
   \   0000E1   A3           INC     DPTR
   \   0000E2   A3           INC     DPTR
   \   0000E3   A3           INC     DPTR
   \   0000E4   A3           INC     DPTR
   \   0000E5   A3           INC     DPTR
   \   0000E6   A3           INC     DPTR
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0000ED   6013         JZ      ??CrossCallReturnLabel_17
   2554                    {
   2555                      osal_mem_free(pSimpleDescRsp->simpleDesc.pAppInClusterList);
   \   0000EF                ; Setup parameters for call to function osal_mem_free
   \   0000EF   85..82       MOV     DPL,?V0 + 0
   \   0000F2   85..83       MOV     DPH,?V0 + 1
   \   0000F5   A3           INC     DPTR
   \   0000F6   A3           INC     DPTR
   \   0000F7   A3           INC     DPTR
   \   0000F8   A3           INC     DPTR
   \   0000F9   A3           INC     DPTR
   \   0000FA   A3           INC     DPTR
   \   0000FB   A3           INC     DPTR
   \   0000FC   A3           INC     DPTR
   \   0000FD   A3           INC     DPTR
   \   0000FE   A3           INC     DPTR
   \   0000FF   12....       LCALL   ?Subroutine11 & 0xFFFF
   2556                    }
   2557          
   2558                    // free memory for OutClusterList
   2559                    if (pSimpleDescRsp->simpleDesc.pAppOutClusterList)
   \                     ??CrossCallReturnLabel_17:
   \   000102   E5..         MOV     A,?V0 + 0
   \   000104   240D         ADD     A,#0xd
   \   000106   F582         MOV     DPL,A
   \   000108   E5..         MOV     A,?V0 + 1
   \   00010A   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   00010D   600E         JZ      ??CrossCallReturnLabel_18
   2560                    {
   2561                      osal_mem_free(pSimpleDescRsp->simpleDesc.pAppOutClusterList);
   \   00010F                ; Setup parameters for call to function osal_mem_free
   \   00010F   E5..         MOV     A,?V0 + 0
   \   000111   240D         ADD     A,#0xd
   \   000113   F582         MOV     DPL,A
   \   000115   E5..         MOV     A,?V0 + 1
   \   000117   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   2562                    }
   \                     ??CrossCallReturnLabel_64:
   \   00011A   12....       LCALL   ?Subroutine11 & 0xFFFF
   2563          
   2564                    osal_mem_free( pSimpleDescRsp );
   \                     ??CrossCallReturnLabel_18:
   \   00011D                ; Setup parameters for call to function osal_mem_free
   \   00011D   AA..         MOV     R2,?V0 + 0
   \   00011F   AB..         MOV     R3,?V0 + 1
   \   000121   12....       LCALL   ??osal_mem_free?relay
   2565                  }
   2566                }
   2567                break;
   2568            }
   2569          }
   \                     ??esp_ProcessZDOMsg_2:
   \   000124   740B         MOV     A,#0xb
   \   000126   12....       LCALL   ?DEALLOC_XSTACK8
   \   000129   02....       LJMP    ?Subroutine1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   F582         MOV     DPL,A
   \   000002   EF           MOV     A,R7
   \   000003                REQUIRE ??Subroutine31_0
   \   000003                ; // Fall through to label ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 0,A
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F5..         MOV     ?V0 + 1,A
   \   00000B   22           RET
   2570          
   2571          
   2572          /******************************************************************************
   2573           *
   2574           *  Functions for processing ZCL Foundation incoming Command/Response messages
   2575           *
   2576           *****************************************************************************/
   2577          
   2578          /*********************************************************************
   2579           * @fn      esp_ProcessZCLMsg
   2580           *
   2581           * @brief   Process ZCL Foundation incoming message
   2582           *
   2583           * @param   pInMsg - message to process
   2584           *
   2585           * @return  none
   2586           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2587          static void esp_ProcessZCLMsg( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessZCLMsg:
   2588          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2589          
   2590          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
   2591            if ( esp_IsMirrorEndpoint( pInMsg->endPoint ) )
   2592            {
   2593              esp_MirrorProcessZCLMsg( pInMsg );
   2594            }
   2595            else
   2596          #endif  // SE_UK_EXT && SE_MIRROR
   2597            {
   2598              switch ( pInMsg->zclHdr.commandID )
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   14           DEC     A
   \   00001B   601A         JZ      ??esp_ProcessZCLMsg_0
   \   00001D   24FD         ADD     A,#-0x3
   \   00001F   6023         JZ      ??esp_ProcessZCLMsg_1
   \   000021   24FE         ADD     A,#-0x2
   \   000023   602C         JZ      ??esp_ProcessZCLMsg_2
   \   000025   14           DEC     A
   \   000026   602E         JZ      ??esp_ProcessZCLMsg_3
   \   000028   14           DEC     A
   \   000029   6078         JZ      ??esp_ProcessZCLMsg_4
   \   00002B   14           DEC     A
   \   00002C   607A         JZ      ??esp_ProcessZCLMsg_5
   \   00002E   14           DEC     A
   \   00002F   7003         JNZ     $+5
   \   000031   02....       LJMP    ??esp_ProcessZCLMsg_6 & 0xFFFF
   \   000034   02....       LJMP    ??esp_ProcessZCLMsg_7 & 0xFFFF
   2599              {
   2600          #if defined ( ZCL_READ )
   2601                case ZCL_CMD_READ_RSP:
   2602                  esp_ProcessInReadRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_0:
   \   000037   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F8           MOV     R0,A
   \   00003C   E9           MOV     A,R1
   \   00003D   C3           CLR     C
   \   00003E   98           SUBB    A,R0
   \   00003F   5077         JNC     ??esp_ProcessZCLMsg_7
   \   000041   09           INC     R1
   \   000042   80F6         SJMP    ??CrossCallReturnLabel_20
   2603                  break;
   2604          #endif // ZCL_READ
   2605          #if defined ( ZCL_WRITE )
   2606                case ZCL_CMD_WRITE_RSP:
   2607                  esp_ProcessInWriteRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_1:
   \   000044   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F8           MOV     R0,A
   \   000049   E9           MOV     A,R1
   \   00004A   C3           CLR     C
   \   00004B   98           SUBB    A,R0
   \   00004C   506A         JNC     ??esp_ProcessZCLMsg_7
   \   00004E   09           INC     R1
   \   00004F   80F6         SJMP    ??CrossCallReturnLabel_21
   2608                  break;
   2609          #endif // ZCL_WRITE
   2610          #if defined ( ZCL_REPORT )
   2611                case ZCL_CMD_CONFIG_REPORT:
   2612                  esp_ProcessInConfigReportCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_2:
   \   000051                ; Setup parameters for call to function esp_ProcessInConfigReportCmd
   \   000051   12....       LCALL   ??esp_ProcessInConfigReportCmd?relay
   2613                  break;
   \   000054   8062         SJMP    ??esp_ProcessZCLMsg_7
   2614          
   2615                case ZCL_CMD_CONFIG_REPORT_RSP:
   2616                  esp_ProcessInConfigReportRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_3:
   \   000056   EE           MOV     A,R6
   \   000057   2417         ADD     A,#0x17
   \   000059   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   00005C   75..00       MOV     ?V0 + 4,#0x0
   \                     ??esp_ProcessZCLMsg_8:
   \   00005F   85..82       MOV     DPL,?V0 + 0
   \   000062   85..83       MOV     DPH,?V0 + 1
   \   000065   E0           MOVX    A,@DPTR
   \   000066   F8           MOV     R0,A
   \   000067   E5..         MOV     A,?V0 + 4
   \   000069   C3           CLR     C
   \   00006A   98           SUBB    A,R0
   \   00006B   504B         JNC     ??esp_ProcessZCLMsg_7
   \   00006D                ; Setup parameters for call to function zclFindAttrRec
   \   00006D   85..82       MOV     DPL,?XSP + 0
   \   000070   85..83       MOV     DPH,?XSP + 1
   \   000073   8582..       MOV     ?V0 + 2,DPL
   \   000076   8583..       MOV     ?V0 + 3,DPH
   \   000079   78..         MOV     R0,#?V0 + 2
   \   00007B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007E   85....       MOV     ?V0 + 2,?V0 + 4
   \   000081   75..00       MOV     ?V0 + 3,#0x0
   \   000084   7402         MOV     A,#0x2
   \   000086   78..         MOV     R0,#?V0 + 2
   \   000088   12....       LCALL   ?S_SHL
   \   00008B   E5..         MOV     A,?V0 + 0
   \   00008D   25..         ADD     A,?V0 + 2
   \   00008F   F582         MOV     DPL,A
   \   000091   E5..         MOV     A,?V0 + 1
   \   000093   35..         ADDC    A,?V0 + 3
   \   000095   F583         MOV     DPH,A
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00009C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009F   05..         INC     ?V0 + 4
   \   0000A1   80BC         SJMP    ??esp_ProcessZCLMsg_8
   2617                  break;
   2618          
   2619                case ZCL_CMD_READ_REPORT_CFG:
   2620                  esp_ProcessInReadReportCfgCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_4:
   \   0000A3                ; Setup parameters for call to function esp_ProcessInReadReportCfgCmd
   \   0000A3   12....       LCALL   ??esp_ProcessInReadReportCfgCmd?relay
   2621                  break;
   \   0000A6   8010         SJMP    ??esp_ProcessZCLMsg_7
   2622          
   2623                case ZCL_CMD_READ_REPORT_CFG_RSP:
   2624                  esp_ProcessInReadReportCfgRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_5:
   \   0000A8   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   F8           MOV     R0,A
   \   0000AD   E9           MOV     A,R1
   \   0000AE   C3           CLR     C
   \   0000AF   98           SUBB    A,R0
   \   0000B0   5006         JNC     ??esp_ProcessZCLMsg_7
   \   0000B2   09           INC     R1
   \   0000B3   80F6         SJMP    ??CrossCallReturnLabel_22
   2625                  break;
   2626          
   2627                case ZCL_CMD_REPORT:
   2628                  esp_ProcessInReportCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_6:
   \   0000B5                ; Setup parameters for call to function esp_ProcessInReportCmd
   \   0000B5   12....       LCALL   ??esp_ProcessInReportCmd?relay
   2629                  break;
   2630          #endif // ZCL_REPORT
   2631                case ZCL_CMD_DEFAULT_RSP:
   2632                  esp_ProcessInDefaultRspCmd( pInMsg );
   2633                  break;
   2634          #if defined ( ZCL_DISCOVER )
   2635                case ZCL_CMD_DISCOVER_RSP:
   2636                  esp_ProcessInDiscRspCmd( pInMsg );
   2637                  break;
   2638          #endif // ZCL_DISCOVER
   2639                default:
   2640                  break;
   2641              }
   2642            }
   2643          
   2644            if ( pInMsg->attrCmd != NULL )
   \                     ??esp_ProcessZCLMsg_7:
   \   0000B8   EE           MOV     A,R6
   \   0000B9   2417         ADD     A,#0x17
   \   0000BB   F582         MOV     DPL,A
   \   0000BD   EF           MOV     A,R7
   \   0000BE   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000C1   601B         JZ      ??esp_ProcessZCLMsg_9
   2645            {
   2646              // free the parsed command
   2647              osal_mem_free( pInMsg->attrCmd );
   \   0000C3   EE           MOV     A,R6
   \   0000C4   2417         ADD     A,#0x17
   \   0000C6   F8           MOV     R0,A
   \   0000C7   EF           MOV     A,R7
   \   0000C8   3400         ADDC    A,#0x0
   \   0000CA   F9           MOV     R1,A
   \   0000CB   E8           MOV     A,R0
   \   0000CC   FE           MOV     R6,A
   \   0000CD   E9           MOV     A,R1
   \   0000CE   FF           MOV     R7,A
   \   0000CF                ; Setup parameters for call to function osal_mem_free
   \   0000CF   8E82         MOV     DPL,R6
   \   0000D1   8F83         MOV     DPH,R7
   \   0000D3   12....       LCALL   ?Subroutine11 & 0xFFFF
   2648              pInMsg->attrCmd = NULL;
   \                     ??CrossCallReturnLabel_19:
   \   0000D6   8E82         MOV     DPL,R6
   \   0000D8   8F83         MOV     DPH,R7
   \   0000DA   E4           CLR     A
   \   0000DB   F0           MOVX    @DPTR,A
   \   0000DC   A3           INC     DPTR
   \   0000DD   F0           MOVX    @DPTR,A
   2649            }
   2650          }
   \                     ??esp_ProcessZCLMsg_9:
   \   0000DE   7408         MOV     A,#0x8
   \   0000E0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E3   7F05         MOV     R7,#0x5
   \   0000E5   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000003   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000006   8882         MOV     DPL,R0
   \   000008   8983         MOV     DPH,R1
   \   00000A   7900         MOV     R1,#0x0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine35_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine36_0
   \   000001                ; // Fall through to label ??Subroutine36_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FA           MOV     R2,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   FB           MOV     R3,A
   \   00000D   7909         MOV     R1,#0x9
   \   00000F   12....       LCALL   ??zclFindAttrRec?relay
   \   000012   7402         MOV     A,#0x2
   \   000014   22           RET
   2651          
   2652          #if defined ( ZCL_READ )
   2653          /*********************************************************************
   2654           * @fn      esp_ProcessInReadRspCmd
   2655           *
   2656           * @brief   Process the "Profile" Read Response Command
   2657           *
   2658           * @param   pInMsg - incoming message to process
   2659           *
   2660           * @return  none
   2661           */
   2662          static uint8 esp_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg )
   2663          {
   2664            zclReadRspCmd_t *readRspCmd;
   2665            uint8 i;
   2666          
   2667            readRspCmd = (zclReadRspCmd_t *)pInMsg->attrCmd;
   2668            for (i = 0; i < readRspCmd->numAttr; i++)
   2669            {
   2670              // Notify the originator of the results of the original read attributes
   2671              // attempt and, for each successfull request, the value of the requested
   2672              // attribute
   2673            }
   2674          
   2675            return TRUE;
   2676          }
   2677          #endif // ZCL_READ
   2678          
   2679          #if defined ( ZCL_WRITE )
   2680          /*********************************************************************
   2681           * @fn      esp_ProcessInWriteRspCmd
   2682           *
   2683           * @brief   Process the "Profile" Write Response Command
   2684           *
   2685           * @param   pInMsg - incoming message to process
   2686           *
   2687           * @return  none
   2688           */
   2689          static uint8 esp_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg )
   2690          {
   2691            zclWriteRspCmd_t *writeRspCmd;
   2692            uint8 i;
   2693          
   2694            writeRspCmd = (zclWriteRspCmd_t *)pInMsg->attrCmd;
   2695            for (i = 0; i < writeRspCmd->numAttr; i++)
   2696            {
   2697              // Notify the device of the results of the its original write attributes
   2698              // command.
   2699            }
   2700          
   2701            return TRUE;
   2702          }
   2703          #endif // ZCL_WRITE
   2704          
   2705          #if defined ( ZCL_REPORT )
   2706          /*********************************************************************
   2707           * @fn      esp_ProcessInConfigReportCmd
   2708           *
   2709           * @brief   Process the "Profile" Configure Reporting Command
   2710           *
   2711           * @param   pInMsg - incoming message to process
   2712           *
   2713           * @return  TRUE if attribute was found in the Attribute list,
   2714           *          FALSE if not
   2715           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2716          static uint8 esp_ProcessInConfigReportCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInConfigReportCmd:
   2717          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2718            zclCfgReportCmd_t *cfgReportCmd;
   2719            zclCfgReportRec_t *reportRec;
   2720            zclCfgReportRspCmd_t *cfgReportRspCmd;
   2721            zclAttrRec_t attrRec;
   2722            uint8 status;
   2723            uint8 i, j = 0;
   \   00000E   75..00       MOV     ?V0 + 4,#0x0
   2724          
   2725            cfgReportCmd = (zclCfgReportCmd_t *)pInMsg->attrCmd;
   \   000011   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000014   F5..         MOV     ?V0 + 2,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 3,A
   2726          
   2727            // Allocate space for the response command
   2728            cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof ( zclCfgReportRspCmd_t ) +
   2729                                                  sizeof ( zclCfgReportStatus_t) * cfgReportCmd->numAttr );
   \   00001A                ; Setup parameters for call to function osal_mem_alloc
   \   00001A   85..82       MOV     DPL,?V0 + 2
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V0 + 0,A
   \   000022   75..00       MOV     ?V0 + 1,#0x0
   \   000025   7402         MOV     A,#0x2
   \   000027   78..         MOV     R0,#?V0 + 0
   \   000029   12....       LCALL   ?S_SHL
   \   00002C   E5..         MOV     A,?V0 + 0
   \   00002E   2401         ADD     A,#0x1
   \   000030   FA           MOV     R2,A
   \   000031   E5..         MOV     A,?V0 + 1
   \   000033   12....       LCALL   ?Subroutine18 & 0xFFFF
   2730            if ( cfgReportRspCmd == NULL )
   \                     ??CrossCallReturnLabel_29:
   \   000036   7005         JNZ     ??esp_ProcessInConfigReportCmd_0
   2731            {
   2732              return FALSE; // EMBEDDED RETURN
   \   000038   7900         MOV     R1,#0x0
   \   00003A   02....       LJMP    ??esp_ProcessInConfigReportCmd_1 & 0xFFFF
   2733            }
   2734          
   2735            // Process each Attribute Reporting Configuration record
   2736            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \                     ??esp_ProcessInConfigReportCmd_0:
   \   00003D   75..00       MOV     ?V0 + 5,#0x0
   \   000040   803A         SJMP    ??esp_ProcessInConfigReportCmd_2
   2737            {
   2738              reportRec = &(cfgReportCmd->attrList[i]);
   2739          
   2740              status = ZCL_STATUS_SUCCESS;
   2741          
   2742              if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId, reportRec->attrID, &attrRec ) )
   2743              {
   2744                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   2745                {
   2746                  if ( reportRec->dataType == attrRec.attr.dataType )
   2747                  {
   2748                    // This the attribute that is to be reported
   2749                    if ( zcl_MandatoryReportableAttribute( &attrRec ) == TRUE )
   2750                    {
   2751                      if ( reportRec->minReportInt < ESP_MIN_REPORTING_INTERVAL ||
   2752                           ( reportRec->maxReportInt != 0 &&
   2753                             reportRec->maxReportInt < reportRec->minReportInt ) )
   2754                      {
   2755                        // Invalid fields
   2756                        status = ZCL_STATUS_INVALID_VALUE;
   2757                      }
   2758                      else
   2759                      {
   2760                        // Set the Min and Max Reporting Intervals and Reportable Change
   2761                        //status = zclSetAttrReportInterval( pAttr, cfgReportCmd );
   2762                        status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE; // for now
   2763                      }
   2764                    }
   2765                    else
   2766                    {
   2767                      // Attribute cannot be reported
   2768                      status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE;
   2769                    }
   2770                  }
   2771                  else
   2772                  {
   2773                    // Attribute data type is incorrect
   2774                    status = ZCL_STATUS_INVALID_DATA_TYPE;
   2775                  }
   2776                }
   2777                else
   2778                {
   2779                  // We shall expect reports of values of this attribute
   2780                  if ( zcl_MandatoryReportableAttribute( &attrRec ) == TRUE )
   2781                  {
   2782                    // Set the Timeout Period
   2783                    //status = zclSetAttrTimeoutPeriod( pAttr, cfgReportCmd );
   2784                    status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE; // for now
   \                     ??esp_ProcessInConfigReportCmd_3:
   \   000042   7A86         MOV     R2,#-0x7a
   2785                  }
   2786                  else
   2787                  {
   2788                    // Reports of attribute cannot be received
   2789                    status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   2790                  }
   2791                }
   2792              }
   2793              else
   2794              {
   2795                // Attribute is not supported
   2796                status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   2797              }
   2798          
   2799              // If not successful then record the status
   2800              if ( status != ZCL_STATUS_SUCCESS )
   2801              {
   2802                cfgReportRspCmd->attrList[j].status = status;
   \                     ??esp_ProcessInConfigReportCmd_4:
   \   000044   85....       MOV     ?V0 + 8,?V0 + 4
   \   000047   75..00       MOV     ?V0 + 9,#0x0
   \   00004A   7402         MOV     A,#0x2
   \   00004C   78..         MOV     R0,#?V0 + 8
   \   00004E   12....       LCALL   ?S_SHL
   \   000051   E5..         MOV     A,?V0 + 6
   \   000053   25..         ADD     A,?V0 + 8
   \   000055   F8           MOV     R0,A
   \   000056   E5..         MOV     A,?V0 + 7
   \   000058   35..         ADDC    A,?V0 + 9
   \   00005A   F9           MOV     R1,A
   \   00005B   EA           MOV     A,R2
   \   00005C   8882         MOV     DPL,R0
   \   00005E   8983         MOV     DPH,R1
   \   000060   A3           INC     DPTR
   \   000061   F0           MOVX    @DPTR,A
   2803                cfgReportRspCmd->attrList[j++].attrID = reportRec->attrID;
   \   000062   85..82       MOV     DPL,?V0 + 0
   \   000065   85..83       MOV     DPH,?V0 + 1
   \   000068   A3           INC     DPTR
   \   000069   12....       LCALL   ?Subroutine15 & 0xFFFF
   2804              }
   \                     ??CrossCallReturnLabel_25:
   \   00006C   8882         MOV     DPL,R0
   \   00006E   8983         MOV     DPH,R1
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   A3           INC     DPTR
   \   000073   EA           MOV     A,R2
   \   000074   F0           MOVX    @DPTR,A
   \   000075   A3           INC     DPTR
   \   000076   EB           MOV     A,R3
   \   000077   F0           MOVX    @DPTR,A
   \   000078   05..         INC     ?V0 + 4
   \   00007A   05..         INC     ?V0 + 5
   \                     ??esp_ProcessInConfigReportCmd_2:
   \   00007C   85..82       MOV     DPL,?V0 + 2
   \   00007F   85..83       MOV     DPH,?V0 + 3
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F8           MOV     R0,A
   \   000084   E5..         MOV     A,?V0 + 5
   \   000086   C3           CLR     C
   \   000087   98           SUBB    A,R0
   \   000088   5061         JNC     ??esp_ProcessInConfigReportCmd_5
   \   00008A   E5..         MOV     A,?V0 + 5
   \   00008C   75F00C       MOV     B,#0xc
   \   00008F   A4           MUL     AB
   \   000090   F8           MOV     R0,A
   \   000091   A9F0         MOV     R1,B
   \   000093   E5..         MOV     A,?V0 + 2
   \   000095   28           ADD     A,R0
   \   000096   F582         MOV     DPL,A
   \   000098   E5..         MOV     A,?V0 + 3
   \   00009A   39           ADDC    A,R1
   \   00009B   F583         MOV     DPH,A
   \   00009D   A3           INC     DPTR
   \   00009E   8582..       MOV     ?V0 + 0,DPL
   \   0000A1   8583..       MOV     ?V0 + 1,DPH
   \   0000A4                ; Setup parameters for call to function zclFindAttrRec
   \   0000A4   85..82       MOV     DPL,?XSP + 0
   \   0000A7   85..83       MOV     DPH,?XSP + 1
   \   0000AA   8582..       MOV     ?V0 + 8,DPL
   \   0000AD   8583..       MOV     ?V0 + 9,DPH
   \   0000B0   78..         MOV     R0,#?V0 + 8
   \   0000B2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B5   85..82       MOV     DPL,?V0 + 0
   \   0000B8   85..83       MOV     DPH,?V0 + 1
   \   0000BB   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0000BE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C1   E9           MOV     A,R1
   \   0000C2   7003         JNZ     $+5
   \   0000C4   02....       LJMP    ??esp_ProcessInConfigReportCmd_3 & 0xFFFF
   \   0000C7   85..82       MOV     DPL,?V0 + 0
   \   0000CA   85..83       MOV     DPH,?V0 + 1
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   6003         JZ      $+5
   \   0000D0   02....       LJMP    ??esp_ProcessInConfigReportCmd_3 & 0xFFFF
   \   0000D3   A3           INC     DPTR
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   E0           MOVX    A,@DPTR
   \   0000D7   F8           MOV     R0,A
   \   0000D8   7404         MOV     A,#0x4
   \   0000DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DD   E0           MOVX    A,@DPTR
   \   0000DE   68           XRL     A,R0
   \   0000DF   7005         JNZ     ??esp_ProcessInConfigReportCmd_6
   \   0000E1   7A8C         MOV     R2,#-0x74
   \   0000E3   02....       LJMP    ??esp_ProcessInConfigReportCmd_4 & 0xFFFF
   \                     ??esp_ProcessInConfigReportCmd_6:
   \   0000E6   7A8D         MOV     R2,#-0x73
   \   0000E8   02....       LJMP    ??esp_ProcessInConfigReportCmd_4 & 0xFFFF
   2805            } // for loop
   2806          
   2807            if ( j == 0 )
   \                     ??esp_ProcessInConfigReportCmd_5:
   \   0000EB   E5..         MOV     A,?V0 + 4
   \   0000ED   85..82       MOV     DPL,?V0 + 6
   \   0000F0   85..83       MOV     DPH,?V0 + 7
   \   0000F3   700A         JNZ     ??esp_ProcessInConfigReportCmd_7
   2808            {
   2809              // Since all attributes were configured successfully, include a single
   2810              // attribute status record in the response command with the status field
   2811              // set to SUCCESS and the attribute ID field omitted.
   2812              cfgReportRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0000F5   A3           INC     DPTR
   \   0000F6   E4           CLR     A
   \   0000F7   F0           MOVX    @DPTR,A
   2813              cfgReportRspCmd->numAttr = 1;
   \   0000F8   85..82       MOV     DPL,?V0 + 6
   \   0000FB   85..83       MOV     DPH,?V0 + 7
   \   0000FE   04           INC     A
   2814            }
   2815            else
   2816            {
   2817              cfgReportRspCmd->numAttr = j;
   \                     ??esp_ProcessInConfigReportCmd_7:
   \   0000FF   12....       LCALL   ?Subroutine5 & 0xFFFF
   2818            }
   2819          
   2820            // Send the response back
   2821            zcl_SendConfigReportRspCmd( ESP_ENDPOINT, &(pInMsg->srcAddr),
   2822                                        pInMsg->clusterId, cfgReportRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   2823                                        TRUE, pInMsg->zclHdr.transSeqNum );
   \                     ??CrossCallReturnLabel_3:
   \   000102   E0           MOVX    A,@DPTR
   \   000103   F5..         MOV     ?V0 + 0,A
   \   000105   78..         MOV     R0,#?V0 + 0
   \   000107   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00010A   75..01       MOV     ?V0 + 0,#0x1
   \   00010D   78..         MOV     R0,#?V0 + 0
   \   00010F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000112   78..         MOV     R0,#?V0 + 0
   \   000114   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000117   78..         MOV     R0,#?V0 + 6
   \   000119   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00011C   8E82         MOV     DPL,R6
   \   00011E   8F83         MOV     DPH,R7
   \   000120   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000123   EE           MOV     A,R6
   \   000124   240A         ADD     A,#0xa
   \   000126   FA           MOV     R2,A
   \   000127   EF           MOV     A,R7
   \   000128   3400         ADDC    A,#0x0
   \   00012A   FB           MOV     R3,A
   \   00012B   7909         MOV     R1,#0x9
   \   00012D   12....       LCALL   ??zcl_SendConfigReportRspCmd?relay
   \   000130   7405         MOV     A,#0x5
   \   000132   12....       LCALL   ?DEALLOC_XSTACK8
   2824            osal_mem_free( cfgReportRspCmd );
   \   000135                ; Setup parameters for call to function osal_mem_free
   \   000135   AA..         MOV     R2,?V0 + 6
   \   000137   AB..         MOV     R3,?V0 + 7
   \   000139   12....       LCALL   ??osal_mem_free?relay
   2825          
   2826            return TRUE ;
   \   00013C   7901         MOV     R1,#0x1
   \                     ??esp_ProcessInConfigReportCmd_1:
   \   00013E                REQUIRE ?Subroutine3
   \   00013E                ; // Fall through to label ?Subroutine3
   2827          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7408         MOV     A,#0x8
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \   000005   7F0A         MOV     R7,#0xa
   \   000007   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   3400         ADDC    A,#0x0
   \   000002   FB           MOV     R3,A
   \   000003   12....       LCALL   ??osal_mem_alloc?relay
   \   000006   8A..         MOV     ?V0 + 6,R2
   \   000008   8B..         MOV     ?V0 + 7,R3
   \   00000A   EA           MOV     A,R2
   \   00000B   45..         ORL     A,?V0 + 7
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine34_0
   \   000006                ; // Fall through to label ??Subroutine34_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine34_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine35_0
   \   000001                ; // Fall through to label ??Subroutine35_0
   2828          
   2829          /*********************************************************************
   2830           * @fn      esp_ProcessInConfigReportRspCmd
   2831           *
   2832           * @brief   Process the "Profile" Configure Reporting Response Command
   2833           *
   2834           * @param   pInMsg - incoming message to process
   2835           *
   2836           * @return  none
   2837           */
   2838          static uint8 esp_ProcessInConfigReportRspCmd( zclIncomingMsg_t *pInMsg )
   2839          {
   2840            zclCfgReportRspCmd_t *cfgReportRspCmd;
   2841            zclAttrRec_t attrRec;
   2842            uint8 i;
   2843          
   2844            cfgReportRspCmd = (zclCfgReportRspCmd_t *)pInMsg->attrCmd;
   2845            for (i = 0; i < cfgReportRspCmd->numAttr; i++)
   2846            {
   2847              if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId,
   2848                                   cfgReportRspCmd->attrList[i].attrID, &attrRec ) )
   2849              {
   2850                // Notify the device of success (or otherwise) of the its original configure
   2851                // reporting command, for each attribute.
   2852              }
   2853            }
   2854          
   2855            return TRUE;
   2856          }
   2857          
   2858          /*********************************************************************
   2859           * @fn      esp_ProcessInReadReportCfgCmd
   2860           *
   2861           * @brief   Process the "Profile" Read Reporting Configuration Command
   2862           *
   2863           * @param   pInMsg - incoming message to process
   2864           *
   2865           * @return  none
   2866           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2867          static uint8 esp_ProcessInReadReportCfgCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInReadReportCfgCmd:
   2868          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   2869            zclReadReportCfgCmd_t *readReportCfgCmd;
   2870            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   2871            zclReportCfgRspRec_t *reportRspRec;
   2872            zclAttrRec_t attrRec;
   2873            uint8 reportChangeLen;
   2874            uint8 *dataPtr;
   2875            uint8 hdrLen;
   2876            uint8 dataLen = 0;
   \   00000E   75..00       MOV     ?V0 + 4,#0x0
   2877            uint8 status;
   2878            uint8 i;
   2879          
   2880            readReportCfgCmd = (zclReadReportCfgCmd_t *)pInMsg->attrCmd;
   \   000011   EA           MOV     A,R2
   \   000012   2417         ADD     A,#0x17
   \   000014   F582         MOV     DPL,A
   \   000016   EB           MOV     A,R3
   \   000017   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FE           MOV     R6,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   FF           MOV     R7,A
   2881          
   2882            // Find out the response length (Reportable Change field is of variable length)
   2883            for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   \   00001F   75..00       MOV     ?V0 + 0,#0x0
   \   000022   804E         SJMP    ??esp_ProcessInReadReportCfgCmd_0
   2884            {
   2885              // For supported attributes with 'analog' data type, find out the length of
   2886              // the Reportable Change field
   2887              if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId,
   2888                                   readReportCfgCmd->attrList[i].attrID, &attrRec ) )
   \                     ??esp_ProcessInReadReportCfgCmd_1:
   \   000024                ; Setup parameters for call to function zclFindAttrRec
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   8582..       MOV     ?V0 + 6,DPL
   \   00002D   8583..       MOV     ?V0 + 7,DPH
   \   000030   78..         MOV     R0,#?V0 + 6
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000035   E5..         MOV     A,?V0 + 0
   \   000037   75F003       MOV     B,#0x3
   \   00003A   A4           MUL     AB
   \   00003B   F8           MOV     R0,A
   \   00003C   A9F0         MOV     R1,B
   \   00003E   EE           MOV     A,R6
   \   00003F   28           ADD     A,R0
   \   000040   F582         MOV     DPL,A
   \   000042   EF           MOV     A,R7
   \   000043   39           ADDC    A,R1
   \   000044   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000047   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004A   E9           MOV     A,R1
   \   00004B   6023         JZ      ??esp_ProcessInReadReportCfgCmd_2
   2889              {
   2890                if ( zclAnalogDataType( attrRec.attr.dataType ) )
   \   00004D                ; Setup parameters for call to function zclAnalogDataType
   \   00004D   7404         MOV     A,#0x4
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F9           MOV     R1,A
   \   000054   12....       LCALL   ??zclAnalogDataType?relay
   \   000057   E9           MOV     A,R1
   \   000058   6016         JZ      ??esp_ProcessInReadReportCfgCmd_2
   2891                {
   2892                   reportChangeLen = zclGetDataTypeLength( attrRec.attr.dataType );
   \   00005A                ; Setup parameters for call to function zclGetDataTypeLength
   \   00005A   7404         MOV     A,#0x4
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   F9           MOV     R1,A
   \   000061   12....       LCALL   ??zclGetDataTypeLength?relay
   \   000064   E9           MOV     A,R1
   \   000065   F8           MOV     R0,A
   2893          
   2894                   // add padding if neede
   2895                   if ( PADDING_NEEDED( reportChangeLen ) )
   \   000066   A2E0         MOV     C,0xE0 /* A   */.0
   \   000068   5001         JNC     ??esp_ProcessInReadReportCfgCmd_3
   2896                   {
   2897                     reportChangeLen++;
   \   00006A   08           INC     R0
   2898                   }
   2899                   dataLen += reportChangeLen;
   \                     ??esp_ProcessInReadReportCfgCmd_3:
   \   00006B   E8           MOV     A,R0
   \   00006C   25..         ADD     A,?V0 + 4
   \   00006E   F5..         MOV     ?V0 + 4,A
   2900                }
   2901              }
   2902            }
   \                     ??esp_ProcessInReadReportCfgCmd_2:
   \   000070   05..         INC     ?V0 + 0
   \                     ??esp_ProcessInReadReportCfgCmd_0:
   \   000072   8E82         MOV     DPL,R6
   \   000074   8F83         MOV     DPH,R7
   \   000076   E0           MOVX    A,@DPTR
   \   000077   F8           MOV     R0,A
   \   000078   E5..         MOV     A,?V0 + 0
   \   00007A   C3           CLR     C
   \   00007B   98           SUBB    A,R0
   \   00007C   40A6         JC      ??esp_ProcessInReadReportCfgCmd_1
   2903          
   2904            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( readReportCfgCmd->numAttr * sizeof( zclReportCfgRspRec_t ) );
   2905          
   2906            // Allocate space for the response command
   2907            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   \   00007E                ; Setup parameters for call to function osal_mem_alloc
   \   00007E   75F00D       MOV     B,#0xd
   \   000081   E0           MOVX    A,@DPTR
   \   000082   A4           MUL     AB
   \   000083   04           INC     A
   \   000084   25..         ADD     A,?V0 + 4
   \   000086   FA           MOV     R2,A
   \   000087   E4           CLR     A
   \   000088   12....       LCALL   ?Subroutine18 & 0xFFFF
   2908            if ( readReportCfgRspCmd == NULL )
   \                     ??CrossCallReturnLabel_30:
   \   00008B   7005         JNZ     ??esp_ProcessInReadReportCfgCmd_4
   2909            {
   2910              return FALSE; // EMBEDDED RETURN
   \   00008D   7900         MOV     R1,#0x0
   \   00008F   02....       LJMP    ??esp_ProcessInReadReportCfgCmd_5 & 0xFFFF
   2911            }
   2912          
   2913            dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   2914            readReportCfgRspCmd->numAttr = readReportCfgCmd->numAttr;
   \                     ??esp_ProcessInReadReportCfgCmd_4:
   \   000092   8E82         MOV     DPL,R6
   \   000094   8F83         MOV     DPH,R7
   \   000096   E0           MOVX    A,@DPTR
   \   000097   8A82         MOV     DPL,R2
   \   000099   8B83         MOV     DPH,R3
   \   00009B   F0           MOVX    @DPTR,A
   2915            for (i = 0; i < readReportCfgCmd->numAttr; i++)
   \   00009C   75..00       MOV     ?V0 + 0,#0x0
   \   00009F   802A         SJMP    ??esp_ProcessInReadReportCfgCmd_6
   2916            {
   2917              reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   2918          
   2919              if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId,
   2920                                   readReportCfgCmd->attrList[i].attrID, &attrRec ) )
   2921              {
   2922                if ( zcl_MandatoryReportableAttribute( &attrRec ) == TRUE )
   2923                {
   2924                  // Get the Reporting Configuration
   2925                  // status = zclReadReportCfg( readReportCfgCmd->attrID[i], reportRspRec );
   2926                  status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE; // for now
   2927                  if ( status == ZCL_STATUS_SUCCESS && zclAnalogDataType( attrRec.attr.dataType ) )
   2928                  {
   2929                    reportChangeLen = zclGetDataTypeLength( attrRec.attr.dataType );
   2930                    //osal_memcpy( dataPtr, pBuf, reportChangeLen );
   2931                    reportRspRec->reportableChange = dataPtr;
   2932          
   2933                    // add padding if needed
   2934                    if ( PADDING_NEEDED( reportChangeLen ) )
   2935                    {
   2936                      reportChangeLen++;
   2937                    }
   2938                    dataPtr += reportChangeLen;
   2939                  }
   2940                }
   2941                else
   2942                {
   2943                  // Attribute not in the Mandatory Reportable Attribute list
   2944                  status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE;
   2945                }
   2946              }
   2947              else
   2948              {
   2949                // Attribute not found
   2950                status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??esp_ProcessInReadReportCfgCmd_7:
   \   0000A1   7486         MOV     A,#-0x7a
   2951              }
   2952          
   2953              reportRspRec->status = status;
   \                     ??esp_ProcessInReadReportCfgCmd_8:
   \   0000A3   85..82       MOV     DPL,?V0 + 4
   \   0000A6   85..83       MOV     DPH,?V0 + 5
   \   0000A9   F0           MOVX    @DPTR,A
   2954              reportRspRec->attrID = readReportCfgCmd->attrList[i].attrID;
   \   0000AA   E5..         MOV     A,?V0 + 0
   \   0000AC   75F003       MOV     B,#0x3
   \   0000AF   A4           MUL     AB
   \   0000B0   F8           MOV     R0,A
   \   0000B1   A9F0         MOV     R1,B
   \   0000B3   EE           MOV     A,R6
   \   0000B4   28           ADD     A,R0
   \   0000B5   F582         MOV     DPL,A
   \   0000B7   EF           MOV     A,R7
   \   0000B8   39           ADDC    A,R1
   \   0000B9   F583         MOV     DPH,A
   \   0000BB   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   0000BE   85..82       MOV     DPL,?V0 + 4
   \   0000C1   85..83       MOV     DPH,?V0 + 5
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   0000C9   05..         INC     ?V0 + 0
   \                     ??esp_ProcessInReadReportCfgCmd_6:
   \   0000CB   8E82         MOV     DPL,R6
   \   0000CD   8F83         MOV     DPH,R7
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   F8           MOV     R0,A
   \   0000D1   E5..         MOV     A,?V0 + 0
   \   0000D3   C3           CLR     C
   \   0000D4   98           SUBB    A,R0
   \   0000D5   504A         JNC     ??esp_ProcessInReadReportCfgCmd_9
   \   0000D7   85..82       MOV     DPL,?V0 + 0
   \   0000DA   AA82         MOV     R2,DPL
   \   0000DC   EA           MOV     A,R2
   \   0000DD   75F00D       MOV     B,#0xd
   \   0000E0   A4           MUL     AB
   \   0000E1   F8           MOV     R0,A
   \   0000E2   A9F0         MOV     R1,B
   \   0000E4   E5..         MOV     A,?V0 + 6
   \   0000E6   28           ADD     A,R0
   \   0000E7   F582         MOV     DPL,A
   \   0000E9   E5..         MOV     A,?V0 + 7
   \   0000EB   39           ADDC    A,R1
   \   0000EC   F583         MOV     DPH,A
   \   0000EE   A3           INC     DPTR
   \   0000EF   8582..       MOV     ?V0 + 4,DPL
   \   0000F2   8583..       MOV     ?V0 + 5,DPH
   \   0000F5                ; Setup parameters for call to function zclFindAttrRec
   \   0000F5   85..82       MOV     DPL,?XSP + 0
   \   0000F8   85..83       MOV     DPH,?XSP + 1
   \   0000FB   8582..       MOV     ?V0 + 8,DPL
   \   0000FE   8583..       MOV     ?V0 + 9,DPH
   \   000101   78..         MOV     R0,#?V0 + 8
   \   000103   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000106   EA           MOV     A,R2
   \   000107   75F003       MOV     B,#0x3
   \   00010A   A4           MUL     AB
   \   00010B   FA           MOV     R2,A
   \   00010C   ABF0         MOV     R3,B
   \   00010E   EE           MOV     A,R6
   \   00010F   2A           ADD     A,R2
   \   000110   F582         MOV     DPL,A
   \   000112   EF           MOV     A,R7
   \   000113   3B           ADDC    A,R3
   \   000114   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000117   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011A   E9           MOV     A,R1
   \   00011B   6084         JZ      ??esp_ProcessInReadReportCfgCmd_7
   \   00011D   748C         MOV     A,#-0x74
   \   00011F   8082         SJMP    ??esp_ProcessInReadReportCfgCmd_8
   2955            }
   2956          
   2957            // Send the response back
   2958            zcl_SendReadReportCfgRspCmd( ESP_ENDPOINT, &(pInMsg->srcAddr),
   2959                                         pInMsg->clusterId, readReportCfgRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   2960                                         TRUE, pInMsg->zclHdr.transSeqNum );
   \                     ??esp_ProcessInReadReportCfgCmd_9:
   \   000121                ; Setup parameters for call to function zcl_SendReadReportCfgRspCmd
   \   000121   85..82       MOV     DPL,?V0 + 2
   \   000124   85..83       MOV     DPH,?V0 + 3
   \   000127   A3           INC     DPTR
   \   000128   A3           INC     DPTR
   \   000129   A3           INC     DPTR
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   A3           INC     DPTR
   \   00012D   E0           MOVX    A,@DPTR
   \   00012E   F5..         MOV     ?V0 + 0,A
   \   000130   78..         MOV     R0,#?V0 + 0
   \   000132   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000135   75..01       MOV     ?V0 + 0,#0x1
   \   000138   78..         MOV     R0,#?V0 + 0
   \   00013A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00013D   78..         MOV     R0,#?V0 + 0
   \   00013F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000142   78..         MOV     R0,#?V0 + 6
   \   000144   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000147   85..82       MOV     DPL,?V0 + 2
   \   00014A   85..83       MOV     DPH,?V0 + 3
   \   00014D   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000150   E5..         MOV     A,?V0 + 2
   \   000152   240A         ADD     A,#0xa
   \   000154   FA           MOV     R2,A
   \   000155   E5..         MOV     A,?V0 + 3
   \   000157   3400         ADDC    A,#0x0
   \   000159   FB           MOV     R3,A
   \   00015A   7909         MOV     R1,#0x9
   \   00015C   12....       LCALL   ??zcl_SendReadReportCfgRspCmd?relay
   \   00015F   7405         MOV     A,#0x5
   \   000161   12....       LCALL   ?DEALLOC_XSTACK8
   2961            osal_mem_free( readReportCfgRspCmd );
   \   000164                ; Setup parameters for call to function osal_mem_free
   \   000164   AA..         MOV     R2,?V0 + 6
   \   000166   AB..         MOV     R3,?V0 + 7
   \   000168   12....       LCALL   ??osal_mem_free?relay
   2962          
   2963            return TRUE;
   \   00016B   7901         MOV     R1,#0x1
   \                     ??esp_ProcessInReadReportCfgCmd_5:
   \   00016D   02....       LJMP    ?Subroutine3 & 0xFFFF
   2964          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   F583         MOV     DPH,A
   \   000002   12....       LCALL   ??Subroutine34_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000005   85..82       MOV     DPL,?V0 + 2
   \   000008   85..83       MOV     DPH,?V0 + 3
   \   00000B   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   00000E   22           RET
   2965          
   2966          /*********************************************************************
   2967           * @fn      esp_ProcessInReadReportCfgRspCmd
   2968           *
   2969           * @brief   Process the "Profile" Read Reporting Configuration Response Command
   2970           *
   2971           * @param   pInMsg - incoming message to process
   2972           *
   2973           * @return  none
   2974           */
   2975          static uint8 esp_ProcessInReadReportCfgRspCmd( zclIncomingMsg_t *pInMsg )
   2976          {
   2977            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   2978            zclReportCfgRspRec_t *reportRspRec;
   2979            uint8 i;
   2980          
   2981            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)pInMsg->attrCmd;
   2982            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   2983            {
   2984              reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   2985          
   2986              // Notify the device of the results of the its original read reporting
   2987              // configuration command.
   2988          
   2989              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   2990              {
   2991                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   2992                {
   2993                  // add user code here
   2994                }
   2995                else
   2996                {
   2997                  // expecting attribute reports
   2998                }
   2999              }
   3000            }
   3001          
   3002            return TRUE;
   3003          }
   3004          
   3005          /*********************************************************************
   3006           * @fn      esp_ProcessInReportCmd
   3007           *
   3008           * @brief   Process the "Profile" Report Command
   3009           *
   3010           * @param   pInMsg - incoming message to process
   3011           *
   3012           * @return  none
   3013           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3014          static uint8 esp_ProcessInReportCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInReportCmd:
   3015          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3016            zclReportCmd_t *reportCmd;
   3017            zclReport_t *reportRec;
   3018            uint8 i;
   3019            uint8 *meterData;
   3020            char lcdBuf[13];
   3021          
   3022            reportCmd = (zclReportCmd_t *)pInMsg->attrCmd;
   \   00000A   EA           MOV     A,R2
   \   00000B   2417         ADD     A,#0x17
   \   00000D   F582         MOV     DPL,A
   \   00000F   EB           MOV     A,R3
   \   000010   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   3023            for (i = 0; i < reportCmd->numAttr; i++)
   \                     ??CrossCallReturnLabel_59:
   \   000013   75..00       MOV     ?V0 + 2,#0x0
   \   000016   806A         SJMP    ??esp_ProcessInReportCmd_0
   3024            {
   3025              // Device is notified of the latest values of the attribute of another device.
   3026              reportRec = &(reportCmd->attrList[i]);
   3027          
   3028              if ( reportRec->attrID == ATTRID_SE_CURRENT_SUMMATION_DELIVERED )
   3029              {
   3030                // process simple metering current summation delivered attribute
   3031                meterData = reportRec->attrData;
   3032          
   3033                // process to convert hex to ascii
   3034                for(i=0; i<6; i++)
   3035                {
   3036                  if(meterData[5-i] == 0)
   3037                  {
   3038                    lcdBuf[i*2] = '0';
   3039                    lcdBuf[i*2+1] = '0';
   3040                  }
   3041                  else if(meterData[5-i] <= 0x0A)
   3042                  {
   3043                    lcdBuf[i*2] = '0';
   3044                    _ltoa(meterData[5-i],(uint8*)&lcdBuf[i*2+1],16);
   3045                  }
   3046                  else
   3047                  {
   3048                    _ltoa(meterData[5-i],(uint8*)&lcdBuf[i*2],16);
   \                     ??esp_ProcessInReportCmd_1:
   \   000018                ; Setup parameters for call to function _ltoa
   \   000018   C3           CLR     C
   \   000019   33           RLC     A
   \   00001A   F8           MOV     R0,A
   \   00001B   E4           CLR     A
   \   00001C   33           RLC     A
   \   00001D   F9           MOV     R1,A
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   E582         MOV     A,DPL
   \   000026   28           ADD     A,R0
   \   000027   F5..         MOV     ?V0 + 4,A
   \   000029   E583         MOV     A,DPH
   \   00002B   39           ADDC    A,R1
   \   00002C   F5..         MOV     ?V0 + 5,A
   \                     ??esp_ProcessInReportCmd_2:
   \   00002E   78..         MOV     R0,#?V0 + 4
   \   000030   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000033   7910         MOV     R1,#0x10
   \   000035   C3           CLR     C
   \   000036   E4           CLR     A
   \   000037   9A           SUBB    A,R2
   \   000038   FC           MOV     R4,A
   \   000039   95E0         SUBB    A,0xE0 /* A   */
   \   00003B   FD           MOV     R5,A
   \   00003C   EE           MOV     A,R6
   \   00003D   2C           ADD     A,R4
   \   00003E   F582         MOV     DPL,A
   \   000040   EF           MOV     A,R7
   \   000041   3D           ADDC    A,R5
   \   000042   F583         MOV     DPH,A
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   FA           MOV     R2,A
   \   00004B   E4           CLR     A
   \   00004C   FC           MOV     R4,A
   \   00004D   FD           MOV     R5,A
   \   00004E   12....       LCALL   ??_ltoa?relay
   \   000051   7402         MOV     A,#0x2
   \   000053   12....       LCALL   ?DEALLOC_XSTACK8
   3049                  }
   \                     ??esp_ProcessInReportCmd_3:
   \   000056   05..         INC     ?V0 + 2
   \   000058   E5..         MOV     A,?V0 + 2
   \   00005A   C3           CLR     C
   \   00005B   9406         SUBB    A,#0x6
   \   00005D   4062         JC      ??esp_ProcessInReportCmd_4
   3050                }
   3051          
   3052                // print out value of current summation delivered in hex
   3053                HalLcdWriteString("Zigbee Coord esp", HAL_LCD_LINE_1);
   \   00005F                ; Setup parameters for call to function HalLcdWriteString
   \   00005F   7900         MOV     R1,#0x0
   \   000061   7A..         MOV     R2,#`?<Constant "Zigbee Coord esp">` & 0xff
   \   000063   7B..         MOV     R3,#(`?<Constant "Zigbee Coord esp">` >> 8) & 0xff
   \   000065   12....       LCALL   ??HalLcdWriteString?relay
   3054                HalLcdWriteString("Curr Summ Dlvd", HAL_LCD_LINE_2);
   \   000068                ; Setup parameters for call to function HalLcdWriteString
   \   000068   7901         MOV     R1,#0x1
   \   00006A   7A..         MOV     R2,#`?<Constant "Curr Summ Dlvd">` & 0xff
   \   00006C   7B..         MOV     R3,#(`?<Constant "Curr Summ Dlvd">` >> 8) & 0xff
   \   00006E   12....       LCALL   ??HalLcdWriteString?relay
   3055                HalLcdWriteString(lcdBuf, HAL_LCD_LINE_3);
   \   000071                ; Setup parameters for call to function HalLcdWriteString
   \   000071   7902         MOV     R1,#0x2
   \   000073   85..82       MOV     DPL,?XSP + 0
   \   000076   85..83       MOV     DPH,?XSP + 1
   \   000079   AA82         MOV     R2,DPL
   \   00007B   AB83         MOV     R3,DPH
   \   00007D   12....       LCALL   ??HalLcdWriteString?relay
   \                     ??esp_ProcessInReportCmd_5:
   \   000080   05..         INC     ?V0 + 2
   \                     ??esp_ProcessInReportCmd_0:
   \   000082   85..82       MOV     DPL,?V0 + 0
   \   000085   85..83       MOV     DPH,?V0 + 1
   \   000088   E0           MOVX    A,@DPTR
   \   000089   F8           MOV     R0,A
   \   00008A   E5..         MOV     A,?V0 + 2
   \   00008C   C3           CLR     C
   \   00008D   98           SUBB    A,R0
   \   00008E   4003         JC      $+5
   \   000090   02....       LJMP    ??esp_ProcessInReportCmd_6 & 0xFFFF
   \   000093   E5..         MOV     A,?V0 + 2
   \   000095   75F005       MOV     B,#0x5
   \   000098   A4           MUL     AB
   \   000099   F8           MOV     R0,A
   \   00009A   A9F0         MOV     R1,B
   \   00009C   E5..         MOV     A,?V0 + 0
   \   00009E   28           ADD     A,R0
   \   00009F   F582         MOV     DPL,A
   \   0000A1   E5..         MOV     A,?V0 + 1
   \   0000A3   39           ADDC    A,R1
   \   0000A4   F583         MOV     DPH,A
   \   0000A6   A3           INC     DPTR
   \   0000A7   A882         MOV     R0,DPL
   \   0000A9   A983         MOV     R1,DPH
   \   0000AB   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   0000AE   EA           MOV     A,R2
   \   0000AF   4B           ORL     A,R3
   \   0000B0   70CE         JNZ     ??esp_ProcessInReportCmd_5
   \   0000B2   8882         MOV     DPL,R0
   \   0000B4   8983         MOV     DPH,R1
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   FE           MOV     R6,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   FF           MOV     R7,A
   \   0000BE   75..00       MOV     ?V0 + 2,#0x0
   \                     ??esp_ProcessInReportCmd_4:
   \   0000C1   A8..         MOV     R0,?V0 + 2
   \   0000C3   C3           CLR     C
   \   0000C4   E4           CLR     A
   \   0000C5   98           SUBB    A,R0
   \   0000C6   F8           MOV     R0,A
   \   0000C7   95E0         SUBB    A,0xE0 /* A   */
   \   0000C9   F9           MOV     R1,A
   \   0000CA   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   0000CD   7023         JNZ     ??esp_ProcessInReportCmd_7
   \   0000CF   85..82       MOV     DPL,?V0 + 2
   \   0000D2   E582         MOV     A,DPL
   \   0000D4   C3           CLR     C
   \   0000D5   33           RLC     A
   \   0000D6   FA           MOV     R2,A
   \   0000D7   E4           CLR     A
   \   0000D8   33           RLC     A
   \   0000D9   FB           MOV     R3,A
   \   0000DA   85..82       MOV     DPL,?XSP + 0
   \   0000DD   85..83       MOV     DPH,?XSP + 1
   \   0000E0   E582         MOV     A,DPL
   \   0000E2   2A           ADD     A,R2
   \   0000E3   F582         MOV     DPL,A
   \   0000E5   E583         MOV     A,DPH
   \   0000E7   3B           ADDC    A,R3
   \   0000E8   F583         MOV     DPH,A
   \   0000EA   7430         MOV     A,#0x30
   \   0000EC   F0           MOVX    @DPTR,A
   \   0000ED   A3           INC     DPTR
   \   0000EE   F0           MOVX    @DPTR,A
   \   0000EF   02....       LJMP    ??esp_ProcessInReportCmd_3 & 0xFFFF
   \                     ??esp_ProcessInReportCmd_7:
   \   0000F2   A8..         MOV     R0,?V0 + 2
   \   0000F4   C3           CLR     C
   \   0000F5   E4           CLR     A
   \   0000F6   98           SUBB    A,R0
   \   0000F7   F8           MOV     R0,A
   \   0000F8   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   0000FB   C3           CLR     C
   \   0000FC   940B         SUBB    A,#0xb
   \   0000FE   85..82       MOV     DPL,?V0 + 2
   \   000101   AA82         MOV     R2,DPL
   \   000103   7B00         MOV     R3,#0x0
   \   000105   EA           MOV     A,R2
   \   000106   4003         JC      $+5
   \   000108   02....       LJMP    ??esp_ProcessInReportCmd_1 & 0xFFFF
   \   00010B   C3           CLR     C
   \   00010C   33           RLC     A
   \   00010D   F8           MOV     R0,A
   \   00010E   E4           CLR     A
   \   00010F   33           RLC     A
   \   000110   F9           MOV     R1,A
   \   000111   85..82       MOV     DPL,?XSP + 0
   \   000114   85..83       MOV     DPH,?XSP + 1
   \   000117   E582         MOV     A,DPL
   \   000119   28           ADD     A,R0
   \   00011A   F582         MOV     DPL,A
   \   00011C   E583         MOV     A,DPH
   \   00011E   39           ADDC    A,R1
   \   00011F   F583         MOV     DPH,A
   \   000121   7430         MOV     A,#0x30
   \   000123   F0           MOVX    @DPTR,A
   \   000124                ; Setup parameters for call to function _ltoa
   \   000124   A3           INC     DPTR
   \   000125   8582..       MOV     ?V0 + 4,DPL
   \   000128   8583..       MOV     ?V0 + 5,DPH
   \   00012B   02....       LJMP    ??esp_ProcessInReportCmd_2 & 0xFFFF
   3056              }
   3057            }
   3058            return TRUE;
   \                     ??esp_ProcessInReportCmd_6:
   \   00012E   7901         MOV     R1,#0x1
   \   000130   740D         MOV     A,#0xd
   \   000132   12....       LCALL   ?DEALLOC_XSTACK8
   \   000135   7F06         MOV     R7,#0x6
   \   000137   02....       LJMP    ?BANKED_LEAVE_XDATA
   3059          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   EE           MOV     A,R6
   \   000001   28           ADD     A,R0
   \   000002   F582         MOV     DPL,A
   \   000004   EF           MOV     A,R7
   \   000005   39           ADDC    A,R1
   \   000006   F583         MOV     DPH,A
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for espEp>`:
   \   000000   09           DB 9
   \   000001   ....         DW espTaskID
   \   000003   ....         DW espSimpleDesc
   \   000005   00           DB 0

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for esp_GenCmdCallbacks>`:
   \   000000   ....         DW ??esp_BasicResetCB?relay
   \   000002   ....         DW ??esp_IdentifyCB?relay
   \   000004   ....         DW ??esp_IdentifyQueryRspCB?relay
   \   000006   0000         DW 0H
   \   000008   0000         DW 0H
   \   00000A   0000         DW 0H
   \   00000C   0000         DW 0H
   \   00000E   0000         DW 0H
   \   000010   0000         DW 0H
   \   000012   0000         DW 0H
   \   000014   0000         DW 0H
   \   000016   0000         DW 0H
   \   000018   ....         DW ??esp_AlarmCB?relay
   \   00001A   0000         DW 0H
   \   00001C   0000         DW 0H

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for esp_SECmdCallbacks>`:
   \   000000   ....         DW ??esp_PublishPriceCB?relay
   \   000002   ....         DW ??esp_PublishBlockPeriodCB?relay
   \   000004   ....         DW ??esp_GetCurrentPriceCB?relay
   \   000006   ....         DW ??esp_GetScheduledPriceCB?relay
   \   000008   ....         DW ??esp_PriceAcknowledgementCB?relay
   \   00000A   ....         DW ??esp_GetBlockPeriodCB?relay
   \   00000C   ....         DW ??esp_LoadControlEventCB?relay
   \   00000E   ....         DW ??esp_CancelLoadControlEventCB?relay
   \   000010   ....         DW ??esp_CancelAllLoadControlEventsCB?relay
   \   000012   ....         DW ??esp_ReportEventStatusCB?relay
   \   000014   ....         DW ??esp_GetScheduledEventCB?relay
   \   000016   ....         DW ??esp_GetProfileRspCB?relay
   \   000018   ....         DW ??esp_ReqMirrorCmdCB?relay
   \   00001A   ....         DW ??esp_MirrorRemCmdCB?relay
   \   00001C   ....         DW ??esp_ReqFastPollModeRspCB?relay
   \   00001E   ....         DW ??esp_GetProfileCmdCB?relay
   \   000020   ....         DW ??esp_ReqMirrorRspCB?relay
   \   000022   ....         DW ??esp_MirrorRemRspCB?relay
   \   000024   ....         DW ??esp_ReqFastPollModeCmdCB?relay
   \   000026   ....         DW ??esp_DisplayMessageCB?relay
   \   000028   ....         DW ??esp_CancelMessageCB?relay
   \   00002A   ....         DW ??esp_GetLastMessageCB?relay
   \   00002C   ....         DW ??esp_MessageConfirmationCB?relay
   \   00002E   0000         DW 0H
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   ....         DW ??esp_SupplyStatusRspCB?relay
   \   00003E   ....         DW ??esp_SelAvailEmergencyCreditCmdCB?relay
   \   000040   ....         DW ??esp_ChangeSupplyCmdCB?relay

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_event_loop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessIdentifyTimeChange?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessIdentifyTimeChange

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_HandleKeys?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_HandleKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ValidateAttrDataCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ValidateAttrDataCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_BasicResetCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_BasicResetCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_IdentifyCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_IdentifyCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_IdentifyQueryRspCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_IdentifyQueryRspCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_AlarmCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_AlarmCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetProfileCmdCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetProfileCmdCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetProfileRspCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetProfileRspCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ReqMirrorCmdCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ReqMirrorCmdCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ReqMirrorRspCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ReqMirrorRspCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_MirrorRemCmdCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_MirrorRemCmdCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_MirrorRemRspCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_MirrorRemRspCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ReqFastPollModeCmdCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ReqFastPollModeCmdCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ReqFastPollModeRspCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ReqFastPollModeRspCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetCurrentPriceCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetCurrentPriceCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetScheduledPriceCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetScheduledPriceCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_PriceAcknowledgementCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_PriceAcknowledgementCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetBlockPeriodCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetBlockPeriodCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_PublishPriceCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_PublishPriceCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_PublishBlockPeriodCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_PublishBlockPeriodCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_DisplayMessageCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_DisplayMessageCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_CancelMessageCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_CancelMessageCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetLastMessageCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetLastMessageCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_MessageConfirmationCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_MessageConfirmationCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_SendReportEventStatus?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_SendReportEventStatus

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_LoadControlEventCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_LoadControlEventCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_CancelLoadControlEventCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_CancelLoadControlEventCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_CancelAllLoadControlEventsCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_CancelAllLoadControlEventsCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ReportEventStatusCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ReportEventStatusCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetScheduledEventCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetScheduledEventCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_SelAvailEmergencyCreditCmdCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_SelAvailEmergencyCreditCmdCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ChangeSupplyCmdCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ChangeSupplyCmdCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_SupplyStatusRspCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_SupplyStatusRspCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessZDOMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessZDOMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessZCLMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessZCLMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessInConfigReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessInConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessInReadReportCfgCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessInReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessInReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessInReportCmd

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "TI IPD Test Msg!">`:
   \   000000   54492049     DB "TI IPD Test Msg!"
   \            50442054
   \            65737420
   \            4D736721
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {10485761L, 10485762L, 10485763L, 1`:
   \   000000   0100A000     DD 10485761
   \   000004   0200A000     DD 10485762
   \   000008   0300A000     DD 10485763
   \   00000C   0400A000     DD 10485764
   \   000010   0500A000     DD 10485765

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Fast Polling">`:
   \   000000   46617374     DB "Fast Polling"
   \            20506F6C
   \            6C696E67
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Cur 0x">`:
   \   000000   43757220     DB "Cur 0x"
   \            307800  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "End 0x">`:
   \   000000   456E6420     DB "End 0x"
   \            307800  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "BASE">`:
   \   000000   42415345     DB "BASE"
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {32, 33, 34, 35, 36, 37, 38, 39, 40`:
   \   000000   20           DB 32
   \   000001   21           DB 33
   \   000002   22           DB 34
   \   000003   23           DB 35
   \   000004   24           DB 36
   \   000005   25           DB 37
   \   000006   26           DB 38
   \   000007   27           DB 39
   \   000008   28           DB 40
   \   000009   29           DB 41

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Zigbee Coord esp">`:
   \   000000   5A696762     DB "Zigbee Coord esp"
   \            65652043
   \            6F6F7264
   \            20657370
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Curr Summ Dlvd">`:
   \   000000   43757272     DB "Curr Summ Dlvd"
   \            2053756D
   \            6D20446C
   \            766400  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_12345678:
   \   000000   78563412     DD 305419896

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_80:
   \   000000   80000000     DD 128

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_babeface:
   \   000000   CEFABEBA     DD 3133078222

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_18:
   \   000000   18000000     DD 24

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffffffff:
   \   000000   FFFFFFFF     DD 4294967295

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_aabbccdd:
   \   000000   DDCCBBAA     DD 2864434397
   3060          #endif // ZCL_REPORT
   3061          
   3062          /*********************************************************************
   3063           * @fn      esp_ProcessInDefaultRspCmd
   3064           *
   3065           * @brief   Process the "Profile" Default Response Command
   3066           *
   3067           * @param   pInMsg - incoming message to process
   3068           *
   3069           * @return  none
   3070           */
   3071          static uint8 esp_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg )
   3072          {
   3073            // zclDefaultRspCmd_t *defaultRspCmd = (zclDefaultRspCmd_t *)pInMsg->attrCmd;
   3074          
   3075            // Device is notified of the Default Response command.
   3076          
   3077            return TRUE;
   3078          }
   3079          
   3080          #if defined ( ZCL_DISCOVER )
   3081          /*********************************************************************
   3082           * @fn      esp_ProcessInDiscRspCmd
   3083           *
   3084           * @brief   Process the "Profile" Discover Response Command
   3085           *
   3086           * @param   pInMsg - incoming message to process
   3087           *
   3088           * @return  none
   3089           */
   3090          static uint8 esp_ProcessInDiscRspCmd( zclIncomingMsg_t *pInMsg )
   3091          {
   3092            zclDiscoverRspCmd_t *discoverRspCmd;
   3093            uint8 i;
   3094          
   3095            discoverRspCmd = (zclDiscoverRspCmd_t *)pInMsg->attrCmd;
   3096          
   3097            for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   3098            {
   3099              // Device is notified of the result of its attribute discovery command.
   3100            }
   3101          
   3102            return TRUE;
   3103          }
   3104          #endif // ZCL_DISCOVER
   3105          
   3106          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
   3107          /*********************************************************************
   3108           * @fn      esp_MirrorInit
   3109           *
   3110           * @brief   Initialize the ESP Mirror Subsystem.
   3111           *
   3112           * @param   none
   3113           *
   3114           * @return  none
   3115           */
   3116          static void esp_MirrorInit( void )
   3117          {
   3118            osal_memset( &esp_MirrorControl, 0, sizeof( esp_MirrorControl ) );
   3119          
   3120            // set the attribute
   3121            espPhysicalEnvironment |= PHY_MIRROR_CAPACITY_ENV;
   3122          }
   3123          
   3124          /*********************************************************************
   3125           * @fn      esp_GetMirrorEndpoint
   3126           *
   3127           * @brief   Get the endpoint of a mirror using the Source Address and
   3128           *          source endpoint.
   3129           *
   3130           * @param   srcAddr - source address to lookup
   3131           *
   3132           * @return  Endpoint of the mirror or
   3133           *          ESP_MIRROR_INVALID_ENDPOINT if there is no space
   3134           */
   3135          static uint8 esp_GetMirrorEndpoint( afAddrType_t *srcAddr )
   3136          {
   3137            uint8 i;
   3138          
   3139            for ( i = 0; i < ESP_MAX_MIRRORS; i++ )
   3140            {
   3141              if ( ( esp_MirrorControl.mirrorMask & (1 << i) ) &&
   3142                   ( esp_MirrorControl.mirrorInfo[i].srcAddr == srcAddr->addr.shortAddr ) &&
   3143                   ( esp_MirrorControl.mirrorInfo[i].srcEndpoint == srcAddr->endPoint ) )
   3144              {
   3145                return ( i + ESP_MIRROR_EP_BASE );
   3146              }
   3147            }
   3148          
   3149            return ESP_MIRROR_INVALID_ENDPOINT;
   3150          }
   3151          
   3152          /*********************************************************************
   3153           * @fn      esp_GetMirrorInfo
   3154           *
   3155           * @brief   Get the control information for a mirror endpoint.
   3156           *
   3157           * @param   endpoint - to lookup
   3158           *
   3159           * @return  Pointer to Mirror Information or
   3160           *          NULL if no Mirror found for the Endpoint
   3161           */
   3162          static espMirrorInfo_t *esp_GetMirrorInfo( uint8 endpoint )
   3163          {
   3164            if ( esp_IsMirrorEndpoint( endpoint ) )
   3165            {
   3166              // Get the index to the mirror
   3167              uint8 index = endpoint - ESP_MIRROR_EP_BASE;
   3168          
   3169              // Return a pointer to the attributes
   3170              return &esp_MirrorControl.mirrorInfo[index];
   3171            }
   3172          
   3173            return NULL;
   3174          }
   3175          
   3176          /*********************************************************************
   3177           * @fn      esp_MirrorInitAttributeSet
   3178           *
   3179           * @brief   Adds notification attributes to the mirror endpoint
   3180           *
   3181           * @param   endpoint - Endpoint of the mirror
   3182           *
   3183           * @return  none
   3184           */
   3185          static void esp_MirrorInitAttributeSet( uint8 endpoint )
   3186          {
   3187            espMirrorInfo_t *pInfo = esp_GetMirrorInfo( endpoint );
   3188          
   3189            if ( pInfo != NULL )
   3190            {
   3191              zclAttrRec_t *pAttributes = pInfo->pAttr;
   3192          
   3193              if ( pAttributes != NULL )
   3194              {
   3195                // Note: Attributes 0 through ESP_MIRROR_USER_ATTRIBUTES_POSITION-1 are used for
   3196                // the mirror notify attribute set.  The rest of the attributes are reserved for
   3197                // the meter.  The meter creates attributes with a report attribute command.
   3198                pAttributes[0].clusterID = ZCL_CLUSTER_ID_SE_SIMPLE_METERING;
   3199                pAttributes[0].attr.attrId = ATTRID_SE_NOTIFICATION_CONTROL_FLAGS;
   3200                pAttributes[0].attr.dataType = ZCL_DATATYPE_BITMAP8;
   3201                pAttributes[0].attr.accessControl = ACCESS_CONTROL_READ | ACCESS_CONTROL_WRITE;
   3202                pAttributes[0].attr.dataPtr = &pInfo->notificationControl;
   3203          
   3204                pAttributes[1].clusterID = ZCL_CLUSTER_ID_SE_SIMPLE_METERING;
   3205                pAttributes[1].attr.attrId = ATTRID_SE_NOTIFICATION_FLAGS;
   3206                pAttributes[1].attr.dataType = ZCL_DATATYPE_BITMAP8;
   3207                pAttributes[1].attr.accessControl = ACCESS_CONTROL_READ;
   3208                pAttributes[1].attr.dataPtr = &pInfo->notificationSet.NotificationFlags;
   3209          
   3210                pAttributes[2].clusterID = ZCL_CLUSTER_ID_SE_SIMPLE_METERING;
   3211                pAttributes[2].attr.attrId = ATTRID_SE_PRICE_NOTIFICATION_FLAGS;
   3212                pAttributes[2].attr.dataType = ZCL_DATATYPE_BITMAP16;
   3213                pAttributes[2].attr.accessControl = ACCESS_CONTROL_READ;
   3214                pAttributes[2].attr.dataPtr = &pInfo->notificationSet.PriceNotificationFlags;
   3215          
   3216                pAttributes[3].clusterID = ZCL_CLUSTER_ID_SE_SIMPLE_METERING;
   3217                pAttributes[3].attr.attrId = ATTRID_SE_CALENDAR_NOTIFICATION_FLAGS;
   3218                pAttributes[3].attr.dataType = ZCL_DATATYPE_BITMAP8;
   3219                pAttributes[3].attr.accessControl = ACCESS_CONTROL_READ;
   3220                pAttributes[3].attr.dataPtr = &pInfo->notificationSet.CalendarNotificationFlags;
   3221          
   3222                pAttributes[4].clusterID = ZCL_CLUSTER_ID_SE_SIMPLE_METERING;
   3223                pAttributes[4].attr.attrId = ATTRID_SE_PRE_PAY_NOTIFICATION_FLAGS;
   3224                pAttributes[4].attr.dataType = ZCL_DATATYPE_BITMAP16;
   3225                pAttributes[4].attr.accessControl = ACCESS_CONTROL_READ;
   3226                pAttributes[4].attr.dataPtr = &pInfo->notificationSet.PrePayNotificationFlags;
   3227          
   3228                pAttributes[5].clusterID = ZCL_CLUSTER_ID_SE_SIMPLE_METERING;
   3229                pAttributes[5].attr.attrId = ATTRID_SE_DEVICE_MANAGEMENT_FLAGS;
   3230                pAttributes[5].attr.dataType = ZCL_DATATYPE_BITMAP8;
   3231                pAttributes[5].attr.accessControl = ACCESS_CONTROL_READ;
   3232                pAttributes[5].attr.dataPtr = &pInfo->notificationSet.DeviceMgmtNotificationFlags;
   3233              }
   3234            }
   3235          }
   3236          
   3237          /*********************************************************************
   3238           * @fn      esp_AllocMirror
   3239           *
   3240           * @brief   Allocate a mirror endpoint in the mirror control structure.
   3241           *
   3242           * @param   srcAddr - of the device requesting a Mirror
   3243           *
   3244           * @return  Endpoint of the mirror or
   3245           *          ESP_MIRROR_INVALID_ENDPOINT if there is no space
   3246           */
   3247          static uint8 esp_AllocMirror( afAddrType_t *srcAddr )
   3248          {
   3249            uint8 i;
   3250            zclAttrRec_t *pAttr;
   3251            uint8 endpoint;
   3252          
   3253            // Verify space is available for another mirror endpoint
   3254            if ( esp_MirrorControl.mirrorMask != ESP_MIRROR_FULL_MASK )
   3255            {
   3256              // Allocate memory for the attribute table
   3257              pAttr = osal_mem_alloc( sizeof( zclAttrRec_t ) * ESP_MIRROR_MAX_ATTRIBUTES );
   3258          
   3259              if ( pAttr != NULL )
   3260              {
   3261                // Initialize the attribute
   3262                osal_memset( pAttr, 0, sizeof( zclAttrRec_t ) * ESP_MIRROR_MAX_ATTRIBUTES );
   3263          
   3264                // Set the attribute clusters to 0xFFFF indicating they are not in use
   3265                for ( i = 0; i < ESP_MIRROR_MAX_ATTRIBUTES; i++ )
   3266                {
   3267                  pAttr[i].clusterID = 0xFFFF;
   3268                }
   3269          
   3270                // Find the next free endpoint slot
   3271                for ( i = 0; i < ESP_MAX_MIRRORS; i++ )
   3272                {
   3273                  if ( esp_MirrorControl.mirrorMask & (1 << i) )
   3274                  {
   3275                    continue;
   3276                  }
   3277          
   3278                  endpoint = i + ESP_MIRROR_EP_BASE;
   3279          
   3280                  // Zero out the info memory
   3281                  osal_memset( &esp_MirrorControl.mirrorInfo[i], 0, sizeof( espMirrorInfo_t ) );
   3282          
   3283                  // Setup mirror information
   3284                  esp_MirrorControl.mirrorMask |= 1 << i;
   3285                  esp_MirrorControl.mirrorInfo[i].srcAddr = srcAddr->addr.shortAddr;
   3286                  esp_MirrorControl.mirrorInfo[i].srcEndpoint = srcAddr->endPoint;
   3287                  esp_MirrorControl.mirrorInfo[i].pAttr = pAttr;
   3288          
   3289                  // Create attributes for the notification set
   3290                  esp_MirrorInitAttributeSet( endpoint );
   3291          
   3292                  // If all endpoints are in use, set the PhysicalEnvironment attribute
   3293                  // indicating all mirror slot are used
   3294                  if ( esp_MirrorControl.mirrorMask == ESP_MIRROR_FULL_MASK )
   3295                  {
   3296                    espPhysicalEnvironment &= ~PHY_MIRROR_CAPACITY_ENV;
   3297                  }
   3298          
   3299                  return endpoint;
   3300                }
   3301          
   3302                // Free the attribute memory if we could not allocate the endpoint
   3303                osal_mem_free( pAttr );
   3304              }
   3305            }
   3306          
   3307            return ESP_MIRROR_INVALID_ENDPOINT;
   3308          }
   3309          
   3310          /*********************************************************************
   3311           * @fn      esp_FreeMirror
   3312           *
   3313           * @brief   Free a mirror endpoint in the mirror control structure.
   3314           *
   3315           * @param   endPoint - Endpoint of the mirror to free
   3316           *
   3317           * @return  none
   3318           */
   3319          void esp_FreeMirror( uint8 endPoint )
   3320          {
   3321            if ( esp_IsMirrorEndpoint( endPoint ) )
   3322            {
   3323              // Get the index to the mirror
   3324              uint8 index = endPoint - ESP_MIRROR_EP_BASE;
   3325              uint8 i;
   3326          
   3327              // Clear the endpoint bit in the mask of allocated mirrors
   3328              esp_MirrorControl.mirrorMask &= ~(1 << index);
   3329          
   3330              if ( esp_MirrorControl.mirrorInfo[index].pAttr )
   3331              {
   3332                // Free the user attribute data
   3333                for ( i = ESP_MIRROR_USER_ATTRIBUTES_POSITION; i < ESP_MIRROR_MAX_ATTRIBUTES; i++ )
   3334                {
   3335                  if ( esp_MirrorControl.mirrorInfo[index].pAttr[i].attr.dataPtr )
   3336                  {
   3337                    osal_mem_free( esp_MirrorControl.mirrorInfo[index].pAttr[i].attr.dataPtr );
   3338                    esp_MirrorControl.mirrorInfo[index].pAttr[i].attr.dataPtr = NULL;
   3339                  }
   3340                }
   3341          
   3342                // Free the attribute table
   3343                osal_mem_free( esp_MirrorControl.mirrorInfo[index].pAttr );
   3344                esp_MirrorControl.mirrorInfo[index].pAttr = NULL;
   3345              }
   3346            }
   3347          }
   3348          
   3349          /*********************************************************************
   3350           * @fn      esp_IsMirrorEndpoint
   3351           *
   3352           * @brief   Check if the endpoint is in the mirror block of endpoints.
   3353           *
   3354           * @param   endpoint - Endpoint of the mirror to free
   3355           *
   3356           * @return  TRUE - if Endpoint is in the Mirror Block
   3357           *          FALSE - Otherwise
   3358           */
   3359          static uint8 esp_IsMirrorEndpoint( uint8 endpoint )
   3360          {
   3361            if ( (endpoint >= ESP_MIRROR_EP_BASE ) &&
   3362                 (endpoint <= ESP_MIRROR_EP_BASE + ESP_MAX_MIRRORS ) )
   3363            {
   3364              return TRUE;
   3365            }
   3366          
   3367            return FALSE;
   3368          }
   3369          
   3370          /*********************************************************************
   3371           * @fn      esp_MirrorUpdateAttribute
   3372           *
   3373           * @brief   Update Attributes in Mirror
   3374           *
   3375           * @param   endpoint - Endpoint of the mirror to free
   3376           *          cluster - Cluster ID
   3377           *          pReport - Pointer to reported attributes
   3378           *
   3379           * @return  TRUE - if Data updated
   3380           *          FALSE - Otherwise
   3381           */
   3382          static uint8 esp_MirrorUpdateAttribute( uint8 endpoint, uint16 cluster, zclReport_t *pReport )
   3383          {
   3384            espMirrorInfo_t *pInfo = esp_GetMirrorInfo( endpoint );
   3385          
   3386            if ( pInfo != NULL )
   3387            {
   3388              zclAttrRec_t *pAttributes = pInfo->pAttr;
   3389              uint8 i;
   3390          
   3391              if ( pAttributes != NULL )
   3392              {
   3393                // Check if the attribute already exists
   3394                for ( i = ESP_MIRROR_USER_ATTRIBUTES_POSITION; i < ESP_MIRROR_MAX_ATTRIBUTES; i++ )
   3395                {
   3396                  if ( pAttributes[i].clusterID == cluster )
   3397                  {
   3398                    if ( pAttributes[i].attr.attrId == pReport->attrID )
   3399                    {
   3400                      if ( pAttributes[i].attr.dataPtr )
   3401                      {
   3402                        // Update the attribute data
   3403                        zclSerializeData( pReport->dataType, pReport->attrData, pAttributes[i].attr.dataPtr );
   3404                        return TRUE;
   3405                      }
   3406                    }
   3407                  }
   3408                }
   3409          
   3410                // Look for a free attribute slot and add the attribute
   3411                for ( i = ESP_MIRROR_USER_ATTRIBUTES_POSITION; i < ESP_MIRROR_MAX_ATTRIBUTES; i++ )
   3412                {
   3413                  if ( pAttributes[i].attr.dataPtr == NULL )
   3414                  {
   3415                    uint8 dataLength = zclGetDataTypeLength( pReport->dataType );
   3416          
   3417                    if ( dataLength > 0 )
   3418                    {
   3419                      pAttributes[i].clusterID = cluster;
   3420                      pAttributes[i].attr.attrId = pReport->attrID;
   3421                      pAttributes[i].attr.dataType = pReport->dataType;
   3422                      pAttributes[i].attr.accessControl = ACCESS_CONTROL_READ;
   3423                      pAttributes[i].attr.dataPtr = osal_mem_alloc( dataLength );
   3424          
   3425                      if ( pAttributes[i].attr.dataPtr != NULL )
   3426                      {
   3427                        zclSerializeData( pReport->dataType, pReport->attrData, pAttributes[i].attr.dataPtr );
   3428                        return TRUE;
   3429                      }
   3430                    }
   3431                  }
   3432                }
   3433              }
   3434            }
   3435          
   3436            return FALSE;
   3437          }
   3438          
   3439          /*********************************************************************
   3440           * @fn      esp_MirrorProcessZCLMsg
   3441           *
   3442           * @brief   Process ZCL messages for mirror endpoints.
   3443           *
   3444           * @param   pInMsg - ZCL Message
   3445           *
   3446           * @return  none
   3447           */
   3448          static void esp_MirrorProcessZCLMsg( zclIncomingMsg_t *pInMsg )
   3449          {
   3450            uint8 i;
   3451          
   3452            if ( pInMsg->zclHdr.commandID == ZCL_CMD_REPORT )
   3453            {
   3454              zclReportCmd_t *reportCmd = (zclReportCmd_t *)pInMsg->attrCmd;
   3455          
   3456              if ( reportCmd != NULL)
   3457              {
   3458                for (i = 0; i < reportCmd->numAttr; i++)
   3459                {
   3460                  // Update the attribute
   3461                  esp_MirrorUpdateAttribute( pInMsg->endPoint, pInMsg->clusterId, &reportCmd->attrList[i] );
   3462                }
   3463              }
   3464          
   3465              // Build a response
   3466              espMirrorInfo_t *pInfo = esp_GetMirrorInfo( pInMsg->srcAddr.endPoint );
   3467          
   3468              if ( pInfo != NULL )
   3469              {
   3470                if ( pInfo->notificationControl & SE_NOTIFICATION_REPORT_ATTR_RSP_BIT )
   3471                {
   3472                  // Send a mirror report attr rsp using the notification set from the mirror info
   3473                  zclSE_SimpleMetering_Send_MirrorReportAttrRsp( pInMsg->endPoint, &pInMsg->srcAddr,
   3474                                                                 &pInfo->notificationSet, TRUE,
   3475                                                                 pInMsg->zclHdr.transSeqNum);
   3476                }
   3477              }
   3478            }
   3479          }
   3480          #endif  // SE_UK_EXT && SE_MIRROR
   3481          /****************************************************************************
   3482          ****************************************************************************/

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     esp_AlarmCB                        0      0      0
     esp_BasicResetCB                   0      0      0
     esp_CancelAllLoadControlEventsCB
                                        0      0      0
     esp_CancelLoadControlEventCB       0      0     19
       -> esp_SendReportEventStatus     0      0     38
     esp_CancelMessageCB                0      0      0
     esp_ChangeSupplyCmdCB              0      0      0
     esp_DisplayMessageCB               2      0      0
       -> HalLcdWriteString             4      0      0
     esp_GetBlockPeriodCB               0      0      0
     esp_GetCurrentPriceCB              0      0     62
       -> osal_memset                   0      0    118
       -> osal_mem_alloc                0      0    118
       -> osal_memcpy                   0      0    124
       -> osal_getClock                 0      0    118
       -> osal_memcpy                   0      0    124
       -> zclSE_Pricing_Send_PublishPrice
                                        0      0    122
       -> osal_mem_free                 0      0    118
     esp_GetLastMessageCB               2      0     40
       -> zclSE_Message_Send_DisplayMessage
                                        0      0     80
     esp_GetProfileCmdCB                2      0     40
       -> zclSE_SimpleMetering_Send_GetProfileRsp
                                        0      0     80
     esp_GetProfileRspCB                0      0      0
     esp_GetScheduledEventCB            0      0      0
     esp_GetScheduledPriceCB            0      0     56
       -> osal_memset                   0      0    108
       -> zclSE_Pricing_Send_PublishPrice
                                        0      0    112
     esp_HandleKeys                     2      0     58
       -> zclSE_LoadControl_Send_LoadControlEvent
                                        0      0     92
       -> zclSE_LoadControl_Send_LoadControlEvent
                                        0      0     92
       -> zclSE_Message_Send_DisplayMessage
                                        0      0     92
     esp_IdentifyCB                     2      0      0
       -> esp_ProcessIdentifyTimeChange
                                        4      0      0
     esp_IdentifyQueryRspCB             0      0      0
     esp_Init                           0      0     13
       -> zclSE_Init                    0      0     22
       -> zclGeneral_RegisterCmdCallbacks
                                        0      0     22
       -> zclSE_RegisterCmdCallbacks
                                        0      0     22
       -> zcl_registerAttrList          0      0     22
       -> zcl_registerClusterOptionList
                                        0      0     22
       -> zcl_registerValidateAttrData
                                        0      0     22
       -> zcl_registerForMsg            0      0     22
       -> ZDO_RegisterForZDOMsg         0      0     22
       -> ZDO_RegisterForZDOMsg         0      0     22
       -> RegisterForKeys               0      0     22
       -> StubAPS_RegisterApp           0      0     22
       -> osal_start_timerEx            0      0     22
       -> zgSetItem                     0      0     26
     esp_LoadControlEventCB             0      0     20
       -> esp_SendReportEventStatus     0      0     38
     esp_MessageConfirmationCB          0      0      0
     esp_MirrorRemCmdCB                 0      0      0
     esp_MirrorRemRspCB                 0      0      0
     esp_PriceAcknowledgementCB         0      0      0
     esp_ProcessIdentifyTimeChange      2      0     12
       -> osal_start_timerEx            4      0      0
       -> HalLedBlink                   4      0      0
       -> HalLedSet                     4      0      0
       -> osal_stop_timerEx             4      0      0
     esp_ProcessInConfigReportCmd       1      0     52
       -> osal_mem_alloc                0      0     52
       -> zclFindAttrRec                0      0     56
       -> zcl_SendConfigReportRspCmd
                                        0      0     62
       -> osal_mem_free                 0      0     52
     esp_ProcessInReadReportCfgCmd      1      0     52
       -> zclFindAttrRec                0      0     56
       -> zclAnalogDataType             0      0     52
       -> zclGetDataTypeLength          0      0     52
       -> osal_mem_alloc                0      0     52
       -> zclFindAttrRec                0      0     56
       -> zcl_SendReadReportCfgRspCmd
                                        0      0     62
       -> osal_mem_free                 0      0     52
     esp_ProcessInReportCmd             0      0     50
       -> _ltoa                         0      0     58
       -> HalLcdWriteString             0      0     54
       -> HalLcdWriteString             0      0     54
       -> HalLcdWriteString             0      0     54
       -> _ltoa                         0      0     58
     esp_ProcessZCLMsg                  0      0     35
       -> esp_ProcessInConfigReportCmd
                                        0      0     42
       -> zclFindAttrRec                0      0     46
       -> esp_ProcessInReadReportCfgCmd
                                        0      0     42
       -> esp_ProcessInReportCmd        0      0     42
       -> osal_mem_free                 0      0     42
     esp_ProcessZDOMsg                  0      0     35
       -> ZDO_ParseDeviceAnnce          0      0     46
       -> osal_set_event                0      0     46
       -> osal_mem_alloc                0      0     46
       -> ZDO_ParseSimpleDescRsp        0      0     46
       -> osal_mem_free                 0      0     46
       -> osal_mem_free                 0      0     46
       -> osal_mem_free                 0      0     46
     esp_PublishBlockPeriodCB           0      0      0
     esp_PublishPriceCB                 0      0      0
     esp_ReportEventStatusCB            0      0      0
     esp_ReqFastPollModeCmdCB           1      0     29
       -> osal_start_timerEx            0      0     54
       -> osal_getClock                 0      0     54
       -> zclSE_SimpleMetering_Send_ReqFastPollModeRsp
                                        0      0     58
       -> HalLcdWriteString             0      0     54
       -> HalLcdWriteStringValue        0      0     56
       -> HalLcdWriteStringValue        0      0     56
     esp_ReqFastPollModeRspCB           0      0      0
     esp_ReqMirrorCmdCB                 0      0      0
     esp_ReqMirrorRspCB                 0      0      0
     esp_SelAvailEmergencyCreditCmdCB
                                        0      0      0
     esp_SendReportEventStatus          1      0     46
       -> osal_mem_alloc                0      0     48
       -> osal_memcpy                   0      0     54
       -> zclSE_LoadControl_Send_ReportEventStatus
                                        0      0     52
       -> osal_mem_free                 0      0     48
     esp_SupplyStatusRspCB              0      0      0
     esp_ValidateAttrDataCB             2      0      0
     esp_event_loop                     0      0     13
       -> esp_ProcessIdentifyTimeChange
                                        0      0     24
       -> esp_ProcessZDOMsg             0      0     24
       -> osal_msg_deallocate           0      0     24
       -> osal_msg_receive              0      0     24
       -> esp_ProcessZCLMsg             0      0     24
       -> esp_HandleKeys                0      0     24
       -> osal_getClock                 0      0     24
       -> osal_start_timerEx            0      0     24
       -> ZDP_SimpleDescReq             0      0     26
       -> osal_start_timerEx            0      0     24


   Segment part sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     espTaskID                                         1
     ipdAddr                                          12
     pctAddr                                          12
     loadControlAddr                                  12
     simpleDescReqAddr                                 9
     loadControlCmd                                   24
     espFastPollModeDuration                           2
     espEp                                             6
     esp_GenCmdCallbacks                              30
     esp_SECmdCallbacks                               66
     esp_Init                                        247
     ?Subroutine16                                     6
     ??Subroutine26_0                                 11
     ??Subroutine27_0                                  8
     esp_event_loop                                  213
     ?Subroutine1                                      5
     ?Subroutine17                                     9
     ?Subroutine24                                     6
     ?Subroutine4                                     18
     ??Subroutine30_0                                  6
     ??Subroutine36_0                                  6
     esp_ProcessIdentifyTimeChange                    58
     ?Subroutine2                                      7
     esp_HandleKeys                                  220
     ?Subroutine7                                      6
     esp_ValidateAttrDataCB                           56
     esp_BasicResetCB                                  3
     esp_IdentifyCB                                   20
     ?Subroutine13                                     1
     ??Subroutine28_0                                  1
     ??Subroutine29_0                                  4
     esp_IdentifyQueryRspCB                            3
     esp_AlarmCB                                       3
     esp_GetProfileCmdCB                             111
     esp_GetProfileRspCB                               3
     esp_ReqMirrorCmdCB                                3
     esp_ReqMirrorRspCB                                3
     esp_MirrorRemCmdCB                                3
     esp_MirrorRemRspCB                                3
     esp_ReqFastPollModeCmdCB                        276
     ?Subroutine6                                      9
     esp_ReqFastPollModeRspCB                          3
     esp_GetCurrentPriceCB                           390
     ?Subroutine11                                     9
     ?Subroutine15                                     6
     esp_GetScheduledPriceCB                         103
     esp_PriceAcknowledgementCB                        3
     esp_GetBlockPeriodCB                              3
     esp_PublishPriceCB                                3
     esp_PublishBlockPeriodCB                          3
     esp_DisplayMessageCB                             24
     ??Subroutine33_0                                  5
     esp_CancelMessageCB                               3
     esp_GetLastMessageCB                            155
     esp_MessageConfirmationCB                         3
     esp_SendReportEventStatus                       256
     ?Subroutine5                                     12
     ?Subroutine21                                     3
     ??Subroutine32_0                                  3
     ?Subroutine0                                      5
     esp_LoadControlEventCB                           74
     ?Subroutine20                                     5
     ?Subroutine25                                    11
     esp_CancelLoadControlEventCB                     41
     esp_CancelAllLoadControlEventsCB
                                                       3
     esp_ReportEventStatusCB                           3
     esp_GetScheduledEventCB                           3
     esp_SelAvailEmergencyCreditCmdCB
                                                       3
     esp_ChangeSupplyCmdCB                             3
     esp_SupplyStatusRspCB                             3
     ?Subroutine8                                      4
     esp_ProcessZDOMsg                               300
     ?Subroutine14                                     3
     ??Subroutine31_0                                 12
     esp_ProcessZCLMsg                               232
     ?Subroutine12                                    13
     ?Subroutine10                                    11
     ??Subroutine35_0                                  1
     ?Subroutine22                                    21
     esp_ProcessInConfigReportCmd                    318
     ?Subroutine3                                     10
     ?Subroutine18                                    14
     ?Subroutine23                                     6
     ??Subroutine34_0                                  1
     esp_ProcessInReadReportCfgCmd                   368
     ?Subroutine9                                     15
     esp_ProcessInReportCmd                          314
     ?Subroutine19                                    15
     ?<Initializer for espEp>                          6
     ?<Initializer for esp_GenCmdCallbacks>           30
     ?<Initializer for esp_SECmdCallbacks>            66
     ??esp_Init?relay                                  6
     ??esp_event_loop?relay                            6
     ??esp_ProcessIdentifyTimeChange?relay             6
     ??esp_HandleKeys?relay                            6
     ??esp_ValidateAttrDataCB?relay                    6
     ??esp_BasicResetCB?relay                          6
     ??esp_IdentifyCB?relay                            6
     ??esp_IdentifyQueryRspCB?relay                    6
     ??esp_AlarmCB?relay                               6
     ??esp_GetProfileCmdCB?relay                       6
     ??esp_GetProfileRspCB?relay                       6
     ??esp_ReqMirrorCmdCB?relay                        6
     ??esp_ReqMirrorRspCB?relay                        6
     ??esp_MirrorRemCmdCB?relay                        6
     ??esp_MirrorRemRspCB?relay                        6
     ??esp_ReqFastPollModeCmdCB?relay                  6
     ??esp_ReqFastPollModeRspCB?relay                  6
     ??esp_GetCurrentPriceCB?relay                     6
     ??esp_GetScheduledPriceCB?relay                   6
     ??esp_PriceAcknowledgementCB?relay                6
     ??esp_GetBlockPeriodCB?relay                      6
     ??esp_PublishPriceCB?relay                        6
     ??esp_PublishBlockPeriodCB?relay                  6
     ??esp_DisplayMessageCB?relay                      6
     ??esp_CancelMessageCB?relay                       6
     ??esp_GetLastMessageCB?relay                      6
     ??esp_MessageConfirmationCB?relay                 6
     ??esp_SendReportEventStatus?relay                 6
     ??esp_LoadControlEventCB?relay                    6
     ??esp_CancelLoadControlEventCB?relay              6
     ??esp_CancelAllLoadControlEventsCB?relay          6
     ??esp_ReportEventStatusCB?relay                   6
     ??esp_GetScheduledEventCB?relay                   6
     ??esp_SelAvailEmergencyCreditCmdCB?relay          6
     ??esp_ChangeSupplyCmdCB?relay                     6
     ??esp_SupplyStatusRspCB?relay                     6
     ??esp_ProcessZDOMsg?relay                         6
     ??esp_ProcessZCLMsg?relay                         6
     ??esp_ProcessInConfigReportCmd?relay              6
     ??esp_ProcessInReadReportCfgCmd?relay             6
     ??esp_ProcessInReportCmd?relay                    6
     ?<Constant "TI IPD Test Msg!">                   17
     ?<Constant {10485761L, 10485762L, 10485763L, 1   20
     ?<Constant "Fast Polling">                       13
     ?<Constant "Cur 0x">                              7
     ?<Constant "End 0x">                              7
     ?<Constant "BASE">                                5
     ?<Constant {32, 33, 34, 35, 36, 37, 38, 39, 40   10
     ?<Constant "Zigbee Coord esp">                   17
     ?<Constant "Curr Summ Dlvd">                     15
     __Constant_12345678                               4
     __Constant_0                                      4
     __Constant_1                                      4
     __Constant_80                                     4
     __Constant_babeface                               4
     __Constant_18                                     4
     __Constant_ffffffff                               4
     __Constant_aabbccdd                               4

 
 4 127 bytes in segment BANKED_CODE
   246 bytes in segment BANK_RELAYS
   102 bytes in segment XDATA_I
   102 bytes in segment XDATA_ID
   143 bytes in segment XDATA_ROM_C
    72 bytes in segment XDATA_Z
 
 4 475 bytes of CODE  memory
   111 bytes of CONST memory (+ 32 bytes shared)
   174 bytes of XDATA memory

Errors: none
Warnings: none
